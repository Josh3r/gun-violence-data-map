import { hexbin } from 'd3-hexbin';
import { createIterable, log } from '@deck.gl/core';
export function pointToHexbin(props, aggregationParams) {
  const {
    data,
    radius
  } = props;
  const {
    viewport,
    attributes
  } = aggregationParams;
  const radiusCommon = getRadiusInCommon(radius, viewport);
  const screenPoints = [];
  const {
    iterable,
    objectInfo
  } = createIterable(data);
  const positions = attributes.positions.value;
  const {
    size
  } = attributes.positions.getAccessor();

  for (const object of iterable) {
    objectInfo.index++;
    const posIndex = objectInfo.index * size;
    const position = [positions[posIndex], positions[posIndex + 1]];
    const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);

    if (arrayIsFinite) {
      screenPoints.push(Object.assign({
        screenCoord: viewport.projectFlat(position)
      }, object));
    } else {
      log.warn('HexagonLayer: invalid position')();
    }
  }

  const newHexbin = hexbin().radius(radiusCommon).x(d => d.screenCoord[0]).y(d => d.screenCoord[1]);
  const hexagonBins = newHexbin(screenPoints);
  return {
    hexagons: hexagonBins.map((hex, index) => ({
      position: viewport.unprojectFlat([hex.x, hex.y]),
      points: hex,
      index
    }))
  };
}
export function getRadiusInCommon(radius, viewport) {
  const {
    unitsPerMeter
  } = viewport.getDistanceScales();
  return radius * unitsPerMeter[0];
}
//# sourceMappingURL=hexagon-aggregator.js.map