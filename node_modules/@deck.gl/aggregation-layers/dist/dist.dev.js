(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("deck"), require("luma"));
	else if(typeof define === 'function' && define.amd)
		define(["deck", "luma"], factory);
	else if(typeof exports === 'object')
		exports["deck"] = factory(require("deck"), require("luma"));
	else
		root["deck"] = factory(root["deck"], root["luma"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__deck_gl_core__, __WEBPACK_EXTERNAL_MODULE__luma_gl_constants__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/d3-hexbin/index.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/d3-hexbin/index.js ***!
  \**********************************************************************/
/*! exports provided: hexbin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_hexbin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/hexbin */ "../../node_modules/d3-hexbin/src/hexbin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexbin", function() { return _src_hexbin__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "../../node_modules/d3-hexbin/src/hexbin.js":
/*!***************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/d3-hexbin/src/hexbin.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) continue;

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) bin.push(point);
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
});


/***/ }),

/***/ "./bundle.js":
/*!*******************!*\
  !*** ./bundle.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const deckGLLayers = __webpack_require__(/*! ./src */ "./src/index.js");

/* global window, global */
const _global = typeof window === 'undefined' ? global : window;
const deck = _global.deck || {};

// Check if peer dependencies are included
if (!deck.LineLayer) {
  throw new Error('@deck.gl/layers is not found');
}

module.exports = Object.assign(deck, deckGLLayers);


/***/ }),

/***/ "./src/aggregation-layer.js":
/*!**********************************!*\
  !*** ./src/aggregation-layer.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AggregationLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_prop_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/prop-utils */ "./src/utils/prop-utils.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





class AggregationLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["CompositeLayer"] {
  initializeState(dimensions) {
    super.initializeState();

    this.setState({
      // Layer props , when changed doesn't require updating aggregation
      ignoreProps: Object(_utils_prop_utils__WEBPACK_IMPORTED_MODULE_2__["filterProps"])(this.constructor._propTypes, dimensions.data.props),
      dimensions
    });
  }

  updateState(opts) {
    super.updateState(opts);
    const {changeFlags} = opts;
    if (changeFlags.extensionsChanged) {
      const shaders = this.getShaders({});
      if (shaders && shaders.defines) {
        shaders.defines.NON_INSTANCED_MODEL = 1;
      }
      this.updateShaders(shaders);
    }

    // Explictly call to update attributes as 'CompositeLayer' doesn't call this
    this._updateAttributes(opts.props);
  }

  updateAttributes(changedAttributes) {
    // Super classes, can refer to state.changedAttributes to determine what
    // attributes changed
    this.setState({changedAttributes});
  }

  getAttributes() {
    return this.getAttributeManager().getShaderAttributes();
  }

  getModuleSettings() {
    // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle
    // For aggregation layers this is called during updateState to update aggregation data
    // NOTE: it is similar to LayerPass._getModuleParameters() but doesn't inlcude `effects` it is not needed for aggregation
    const {viewport, mousePosition, gl} = this.context;
    const moduleSettings = Object.assign(Object.create(this.props), {
      viewport,
      mousePosition,
      pickingActive: 0,
      devicePixelRatio: Object(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["cssToDeviceRatio"])(gl)
    });
    return moduleSettings;
  }

  updateShaders(shaders) {
    // Default implemention is empty, subclasses can update their Model objects if needed
  }

  /**
   * Checks if aggregation is dirty
   * @param {Object} updateOpts - object {props, oldProps, changeFlags}
   * @param {Object} params - object {dimension, compareAll}
   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
   **/
  isAggregationDirty(updateOpts, params = {}) {
    const {props, oldProps, changeFlags} = updateOpts;
    const {compareAll = false, dimension} = params;
    const {ignoreProps} = this.state;
    const {props: dataProps, accessors = []} = dimension;
    const {updateTriggersChanged} = changeFlags;
    if (updateTriggersChanged) {
      if (updateTriggersChanged.all) {
        return true;
      }
      for (const accessor of accessors) {
        if (updateTriggersChanged[accessor]) {
          return true;
        }
      }
    }
    if (compareAll) {
      if (changeFlags.extensionsChanged) {
        return true;
      }
      // Compare non layer props too (like extension props)
      // ignoreprops refers to all Layer props other than aggregation props that need to be comapred
      return Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["_compareProps"])({
        oldProps,
        newProps: props,
        ignoreProps,
        propTypes: this.constructor._propTypes
      });
    }
    // Compare props of the dimension
    for (const name of dataProps) {
      if (props[name] !== oldProps[name]) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if an attribute is changed
   * @param {String} name - name of the attribute
   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
   **/
  isAttributeChanged(name) {
    const {changedAttributes} = this.state;
    if (!name) {
      // if name not specified return true if any attribute is changed
      return !isObjectEmpty(changedAttributes);
    }
    return changedAttributes && changedAttributes[name] !== undefined;
  }

  // Private

  // override Composite layer private method to create AttributeManager instance
  _getAttributeManager() {
    return new _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["AttributeManager"](this.context.gl, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
}

// Helper methods

// Returns true if given object is empty, false otherwise.
function isObjectEmpty(obj) {
  let isEmpty = true;
  /* eslint-disable no-unused-vars  */
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  /* eslint-enable no-unused-vars  */
  return isEmpty;
}

AggregationLayer.layerName = 'AggregationLayer';


/***/ }),

/***/ "./src/contour-layer/contour-layer.js":
/*!********************************************!*\
  !*** ./src/contour-layer/contour-layer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContourLayer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/layers */ "@deck.gl/core");
/* harmony import */ var _deck_gl_layers__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_layers__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _contour_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contour-utils */ "./src/contour-layer/contour-utils.js");
/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony import */ var _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
/* harmony import */ var _utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/grid-aggregation-utils */ "./src/utils/grid-aggregation-utils.js");
/* harmony import */ var _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../grid-aggregation-layer */ "./src/grid-aggregation-layer.js");
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











const DEFAULT_COLOR = [255, 255, 255, 255];
const DEFAULT_STROKE_WIDTH = 1;
const DEFAULT_THRESHOLD = 1;

const defaultProps = {
  // grid aggregation
  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},
  getPosition: {type: 'accessor', value: x => x.position},
  getWeight: {type: 'accessor', value: x => 1},
  gpuAggregation: true,
  aggregation: 'SUM',

  // contour lines
  contours: [{threshold: DEFAULT_THRESHOLD}],

  zOffset: 0.005
};

const POSITION_ATTRIBUTE_NAME = 'positions';

const DIMENSIONS = {
  data: {
    props: ['cellSize']
  },
  weights: {
    props: ['aggregation'],
    accessors: ['getWeight']
  }
};

class ContourLayer extends _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_6__["default"] {
  initializeState() {
    super.initializeState({
      dimensions: DIMENSIONS
    });
    this.setState({
      contourData: {},
      projectPoints: false,
      weights: {
        count: {
          size: 1,
          operation: _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_4__["AGGREGATION_OPERATION"].SUM
        }
      }
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME]: {
        size: 3,
        accessor: 'getPosition',
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DOUBLE,
        fp64: this.use64bitPositions()
      },
      // this attribute is used in gpu aggregation path only
      count: {size: 3, accessor: 'getWeight'}
    });
  }

  updateState(opts) {
    super.updateState(opts);
    let contoursChanged = false;
    const {oldProps, props} = opts;
    const {aggregationDirty} = this.state;

    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {
      contoursChanged = true;
      this._updateThresholdData(opts.props);
    }

    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {
      this._generateContours();
    }
  }

  renderLayers() {
    const {contourSegments, contourPolygons} = this.state.contourData;

    const LinesSubLayerClass = this.getSubLayerClass('lines', _deck_gl_layers__WEBPACK_IMPORTED_MODULE_1__["LineLayer"]);
    const BandsSubLayerClass = this.getSubLayerClass('bands', _deck_gl_layers__WEBPACK_IMPORTED_MODULE_1__["SolidPolygonLayer"]);

    // Contour lines layer
    const lineLayer =
      contourSegments &&
      contourSegments.length > 0 &&
      new LinesSubLayerClass(
        this.getSubLayerProps({
          id: 'lines'
        }),
        {
          data: this.state.contourData.contourSegments,
          getSourcePosition: d => d.start,
          getTargetPosition: d => d.end,
          getColor: d => d.contour.color || DEFAULT_COLOR,
          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH
        }
      );

    // Contour bands layer
    const bandsLayer =
      contourPolygons &&
      contourPolygons.length > 0 &&
      new BandsSubLayerClass(
        this.getSubLayerProps({
          id: 'bands'
        }),
        {
          data: this.state.contourData.contourPolygons,
          getPolygon: d => d.vertices,
          getFillColor: d => d.contour.color || DEFAULT_COLOR
        }
      );

    return [lineLayer, bandsLayer];
  }

  // Aggregation Overrides

  /* eslint-disable max-statements, complexity */
  updateAggregationState(opts) {
    const {props, oldProps} = opts;
    const {cellSize, coordinateSystem} = props;
    const {viewport} = this.context;
    const cellSizeChanged = oldProps.cellSize !== cellSize;
    let gpuAggregation = props.gpuAggregation;
    if (this.state.gpuAggregation !== props.gpuAggregation) {
      if (gpuAggregation && !_utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_3__["default"].isSupported(this.context.gl)) {
        _deck_gl_layers__WEBPACK_IMPORTED_MODULE_1__["log"].warn('GPU Grid Aggregation not supported, falling back to CPU')();
        gpuAggregation = false;
      }
    }
    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
    this.setState({
      gpuAggregation
    });

    const {dimensions} = this.state;
    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);
    const {data, weights} = dimensions;

    let {boundingBox} = this.state;
    if (positionsChanged) {
      boundingBox = Object(_utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_5__["getBoundingBox"])(this.getAttributes(), this.getNumInstances());
      this.setState({boundingBox});
    }
    if (positionsChanged || cellSizeChanged) {
      const {gridOffset, translation, width, height, numCol, numRow} = Object(_utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_5__["getGridParams"])(
        boundingBox,
        cellSize,
        viewport,
        coordinateSystem
      );
      this.allocateResources(numRow, numCol);
      this.setState({
        gridOffset,
        boundingBox,
        translation,
        posOffset: translation.slice(), // Used for CPU aggregation, to offset points
        gridOrigin: [-1 * translation[0], -1 * translation[1]],
        width,
        height,
        numCol,
        numRow
      });
    }

    const aggregationDataDirty =
      positionsChanged ||
      gpuAggregationChanged ||
      this.isAggregationDirty(opts, {
        dimension: data,
        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation
      });
    const aggregationWeightsDirty = this.isAggregationDirty(opts, {
      dimension: weights
    });

    if (aggregationWeightsDirty) {
      this._updateAccessors(opts);
    }
    if (aggregationDataDirty || aggregationWeightsDirty) {
      this._resetResults();
    }
    this.setState({
      aggregationDataDirty,
      aggregationWeightsDirty
    });
  }
  /* eslint-enable max-statements, complexity */

  // Private (Aggregation)

  _updateAccessors(opts) {
    const {getWeight, aggregation} = opts.props;
    const {count} = this.state.weights;
    if (count) {
      count.getWeight = getWeight;
      count.operation = _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_4__["AGGREGATION_OPERATION"][aggregation];
    }
    this.setState({getValue: Object(_utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_4__["getValueFunc"])(aggregation, getWeight)});
  }

  _resetResults() {
    const {count} = this.state.weights;
    if (count) {
      count.aggregationData = null;
    }
  }

  // Private (Contours)

  _generateContours() {
    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;
    const {count} = this.state.weights;
    let {aggregationData} = count;
    if (!aggregationData) {
      aggregationData = count.aggregationBuffer.getData();
      count.aggregationData = aggregationData;
    }

    const {cellWeights} = _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_3__["default"].getCellData({countsData: aggregationData});
    const contourData = Object(_contour_utils__WEBPACK_IMPORTED_MODULE_2__["generateContours"])({
      thresholdData,
      cellWeights,
      gridSize: [numCol, numRow],
      gridOrigin,
      cellSize: [gridOffset.xOffset, gridOffset.yOffset]
    });

    // contourData contains both iso-lines and iso-bands if requested.
    this.setState({contourData});
  }

  _updateThresholdData(props) {
    const {contours, zOffset} = props;
    const count = contours.length;
    const thresholdData = new Array(count);
    for (let i = 0; i < count; i++) {
      const contour = contours[i];
      thresholdData[i] = {
        contour,
        zIndex: contour.zIndex || i,
        zOffset
      };
    }
    this.setState({thresholdData});
  }
}

ContourLayer.layerName = 'ContourLayer';
ContourLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/contour-layer/contour-utils.js":
/*!********************************************!*\
  !*** ./src/contour-layer/contour-utils.js ***!
  \********************************************/
/*! exports provided: generateContours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateContours", function() { return generateContours; });
/* harmony import */ var _marching_squares__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./marching-squares */ "./src/contour-layer/marching-squares.js");


// Given all the cell weights, generates contours for each threshold.
/* eslint-disable max-depth */
function generateContours({
  thresholdData,
  colors,
  cellWeights,
  gridSize,
  gridOrigin,
  cellSize
}) {
  const contourSegments = [];
  const contourPolygons = [];
  const width = gridSize[0];
  const height = gridSize[1];
  let segmentIndex = 0;
  let polygonIndex = 0;

  for (const data of thresholdData) {
    const {contour} = data;
    const {threshold} = contour;
    for (let x = -1; x < width; x++) {
      for (let y = -1; y < height; y++) {
        // Get the MarchingSquares code based on neighbor cell weights.
        const {code, meanCode} = Object(_marching_squares__WEBPACK_IMPORTED_MODULE_0__["getCode"])({
          cellWeights,
          threshold,
          x,
          y,
          width,
          height
        });
        const opts = {
          gridOrigin,
          cellSize,
          x,
          y,
          width,
          height,
          code,
          meanCode,
          thresholdData: data
        };
        if (Array.isArray(threshold)) {
          opts.type = _marching_squares__WEBPACK_IMPORTED_MODULE_0__["CONTOUR_TYPE"].ISO_BANDS;
          const polygons = Object(_marching_squares__WEBPACK_IMPORTED_MODULE_0__["getVertices"])(opts);
          for (const polygon of polygons) {
            contourPolygons[polygonIndex++] = {
              vertices: polygon,
              contour
            };
          }
        } else {
          // Get the intersection vertices based on MarchingSquares code.
          opts.type = _marching_squares__WEBPACK_IMPORTED_MODULE_0__["CONTOUR_TYPE"].ISO_LINES;
          const vertices = Object(_marching_squares__WEBPACK_IMPORTED_MODULE_0__["getVertices"])(opts);
          for (let i = 0; i < vertices.length; i += 2) {
            contourSegments[segmentIndex++] = {
              start: vertices[i],
              end: vertices[i + 1],
              contour
            };
          }
        }
      }
    }
  }
  return {contourSegments, contourPolygons};
}
/* eslint-enable max-depth */


/***/ }),

/***/ "./src/contour-layer/marching-squares-codes.js":
/*!*****************************************************!*\
  !*** ./src/contour-layer/marching-squares-codes.js ***!
  \*****************************************************/
/*! exports provided: ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ISOLINES_CODE_OFFSET_MAP", function() { return ISOLINES_CODE_OFFSET_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ISOBANDS_CODE_OFFSET_MAP", function() { return ISOBANDS_CODE_OFFSET_MAP; });
// Code to Offsets Map needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares

// Table to map code to the intersection offsets
// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)
const HALF = 0.5;
const ONE6TH = 1 / 6;
const OFFSET = {
  N: [0, HALF], // NORTH
  E: [HALF, 0], // EAST
  S: [0, -HALF], // SOUTH
  W: [-HALF, 0], // WEST

  // CORNERS
  NE: [HALF, HALF],
  NW: [-HALF, HALF],
  SE: [HALF, -HALF],
  SW: [-HALF, -HALF]
};

// NOTE: vertices are ordered in CCW direction, starting from NW corner

// Triangles
const SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
const SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
const NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
const NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];

// Trapezoids
const SW_TRAPEZOID = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [-ONE6TH, -HALF], [ONE6TH, -HALF]];
const SE_TRAPEZOID = [[-ONE6TH, -HALF], [ONE6TH, -HALF], [HALF, -ONE6TH], [HALF, ONE6TH]];
const NE_TRAPEZOID = [[HALF, -ONE6TH], [HALF, ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];
const NW_TRAPEZOID = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];

// Rectangles
const S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
const E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
const N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
const W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
const EW_RECTANGEL = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [HALF, -ONE6TH], [HALF, ONE6TH]];
const SN_RECTANGEL = [[-ONE6TH, -HALF], [ONE6TH, -HALF], [ONE6TH, HALF], [-ONE6TH, HALF]];

// Square
const SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];

// Pentagons
const SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
const SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
const NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
const NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];

const NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
const NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
const SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
const SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];

const NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
const NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
const SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
const SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];

// Hexagon
const S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
const E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
const N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
const W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
const SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
const NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];

// Heptagon (7-sided)
const NE_HEPTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  OFFSET.E,
  OFFSET.NE,
  OFFSET.N
];
const SW_HEPTAGON = [
  OFFSET.W,
  OFFSET.SW,
  OFFSET.S,
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
const NW_HEPTAGON = [
  OFFSET.NW,
  OFFSET.W,
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  OFFSET.N
];
const SE_HEPTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  OFFSET.S,
  OFFSET.SE,
  OFFSET.E,
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];

// Octagon
const OCTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];

// Note: above wiki page invertes white/black dots for generating the code, we don't
const ISOLINES_CODE_OFFSET_MAP = {
  // key is equal to the code of 4 vertices (invert the code specified in wiki)
  // value can be an array or an Object
  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]
  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners
  //  key: code of mean value (0 or 1)
  //  value: Array , as above defines one or two line segments
  0: [],
  1: [[OFFSET.W, OFFSET.S]],
  2: [[OFFSET.S, OFFSET.E]],
  3: [[OFFSET.W, OFFSET.E]],
  4: [[OFFSET.N, OFFSET.E]],
  5: {
    0: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],
    1: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]]
  },
  6: [[OFFSET.N, OFFSET.S]],
  7: [[OFFSET.W, OFFSET.N]],
  8: [[OFFSET.W, OFFSET.N]],
  9: [[OFFSET.N, OFFSET.S]],
  10: {
    0: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],
    1: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]]
  },
  11: [[OFFSET.N, OFFSET.E]],
  12: [[OFFSET.W, OFFSET.E]],
  13: [[OFFSET.S, OFFSET.E]],
  14: [[OFFSET.W, OFFSET.S]],
  15: []
};

function ternaryToIndex(ternary) {
  return parseInt(ternary, 4);
}

const ISOBANDS_CODE_OFFSET_MAP = {
  // Below list of cases, follow the same order as in above mentioned wiki page.
  // Each case has its code on first commented line // T,TR,R,C
  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2
  // final code is binary represenation of above code , where takes 2 digits
  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169

  // no contours
  [ternaryToIndex('0000')]: [],
  [ternaryToIndex('2222')]: [],

  // single triangle
  [ternaryToIndex('2221')]: [SW_TRIANGLE],
  [ternaryToIndex('2212')]: [SE_TRIANGLE],
  [ternaryToIndex('2122')]: [NE_TRIANGLE],
  [ternaryToIndex('1222')]: [NW_TRIANGLE],
  [ternaryToIndex('0001')]: [SW_TRIANGLE],
  [ternaryToIndex('0010')]: [SE_TRIANGLE],
  [ternaryToIndex('0100')]: [NE_TRIANGLE],
  [ternaryToIndex('1000')]: [NW_TRIANGLE],

  // single trapezoid
  [ternaryToIndex('2220')]: [SW_TRAPEZOID],
  [ternaryToIndex('2202')]: [SE_TRAPEZOID],
  [ternaryToIndex('2022')]: [NE_TRAPEZOID],
  [ternaryToIndex('0222')]: [NW_TRAPEZOID],
  [ternaryToIndex('0002')]: [SW_TRAPEZOID],
  [ternaryToIndex('0020')]: [SE_TRAPEZOID],
  [ternaryToIndex('0200')]: [NE_TRAPEZOID],
  [ternaryToIndex('2000')]: [NW_TRAPEZOID],

  // single rectangle
  [ternaryToIndex('0011')]: [S_RECTANGLE],
  [ternaryToIndex('0110')]: [E_RECTANGLE],
  [ternaryToIndex('1100')]: [N_RECTANGLE],
  [ternaryToIndex('1001')]: [W_RECTANGLE],
  [ternaryToIndex('2211')]: [S_RECTANGLE],
  [ternaryToIndex('2112')]: [E_RECTANGLE],
  [ternaryToIndex('1122')]: [N_RECTANGLE],
  [ternaryToIndex('1221')]: [W_RECTANGLE],
  [ternaryToIndex('2200')]: [EW_RECTANGEL],
  [ternaryToIndex('2002')]: [SN_RECTANGEL],
  [ternaryToIndex('0022')]: [EW_RECTANGEL],
  [ternaryToIndex('0220')]: [SN_RECTANGEL],

  // single square
  // 1111
  [ternaryToIndex('1111')]: [SQUARE],

  // single pentagon
  [ternaryToIndex('1211')]: [SW_PENTAGON],
  [ternaryToIndex('2111')]: [SE_PENTAGON],
  [ternaryToIndex('1112')]: [NE_PENTAGON],
  [ternaryToIndex('1121')]: [NW_PENTAGON],
  [ternaryToIndex('1011')]: [SW_PENTAGON],
  [ternaryToIndex('0111')]: [SE_PENTAGON],
  [ternaryToIndex('1110')]: [NE_PENTAGON],
  [ternaryToIndex('1101')]: [NW_PENTAGON],
  [ternaryToIndex('1200')]: [NW_N_PENTAGON],
  [ternaryToIndex('0120')]: [NE_E_PENTAGON],
  [ternaryToIndex('0012')]: [SE_S_PENTAGON],
  [ternaryToIndex('2001')]: [SW_W_PENTAGON],
  [ternaryToIndex('1022')]: [NW_N_PENTAGON],
  [ternaryToIndex('2102')]: [NE_E_PENTAGON],
  [ternaryToIndex('2210')]: [SE_S_PENTAGON],
  [ternaryToIndex('0221')]: [SW_W_PENTAGON],
  [ternaryToIndex('1002')]: [NW_W_PENTAGON],
  [ternaryToIndex('2100')]: [NE_N_PENTAGON],
  [ternaryToIndex('0210')]: [SE_E_PENTAGON],
  [ternaryToIndex('0021')]: [SW_S_PENTAGON],
  [ternaryToIndex('1220')]: [NW_W_PENTAGON],
  [ternaryToIndex('0122')]: [NE_N_PENTAGON],
  [ternaryToIndex('2012')]: [SE_E_PENTAGON],
  [ternaryToIndex('2201')]: [SW_S_PENTAGON],

  // single hexagon
  [ternaryToIndex('0211')]: [S_HEXAGON],
  [ternaryToIndex('2110')]: [E_HEXAGON],
  [ternaryToIndex('1102')]: [N_HEXAGON],
  [ternaryToIndex('1021')]: [W_HEXAGON],
  [ternaryToIndex('2011')]: [S_HEXAGON],
  [ternaryToIndex('0112')]: [E_HEXAGON],
  [ternaryToIndex('1120')]: [N_HEXAGON],
  [ternaryToIndex('1201')]: [W_HEXAGON],
  [ternaryToIndex('2101')]: [SW_NE_HEXAGON],
  [ternaryToIndex('0121')]: [SW_NE_HEXAGON],
  [ternaryToIndex('1012')]: [NW_SE_HEXAGON],
  [ternaryToIndex('1210')]: [NW_SE_HEXAGON],

  // 6-sided polygons based on mean weight
  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)
  [ternaryToIndex('0101')]: {
    0: [SW_TRIANGLE, NE_TRIANGLE],
    1: [SW_NE_HEXAGON],
    2: [SW_NE_HEXAGON]
  },
  [ternaryToIndex('1010')]: {
    0: [NW_TRIANGLE, SE_TRIANGLE],
    1: [NW_SE_HEXAGON],
    2: [NW_SE_HEXAGON]
  },
  [ternaryToIndex('2121')]: {
    0: [SW_NE_HEXAGON],
    1: [SW_NE_HEXAGON],
    2: [SW_TRIANGLE, NE_TRIANGLE]
  },
  [ternaryToIndex('1212')]: {
    0: [NW_SE_HEXAGON],
    1: [NW_SE_HEXAGON],
    2: [NW_TRIANGLE, SE_TRIANGLE]
  },

  // 7-sided polygons based on mean weight
  [ternaryToIndex('2120')]: {
    0: [NE_HEPTAGON],
    1: [NE_HEPTAGON],
    2: [SW_TRAPEZOID, NE_TRIANGLE]
  },
  [ternaryToIndex('2021')]: {
    0: [SW_HEPTAGON],
    1: [SW_HEPTAGON],
    2: [SW_TRIANGLE, NE_TRAPEZOID]
  },
  [ternaryToIndex('1202')]: {
    0: [NW_HEPTAGON],
    1: [NW_HEPTAGON],
    2: [NW_TRIANGLE, SE_TRAPEZOID]
  },
  [ternaryToIndex('0212')]: {
    0: [SE_HEPTAGON],
    1: [SE_HEPTAGON],
    2: [SE_TRIANGLE, NW_TRAPEZOID]
  },
  [ternaryToIndex('0102')]: {
    0: [SW_TRAPEZOID, NE_TRIANGLE],
    1: [NE_HEPTAGON],
    2: [NE_HEPTAGON]
  },
  [ternaryToIndex('0201')]: {
    0: [SW_TRIANGLE, NE_TRAPEZOID],
    1: [SW_HEPTAGON],
    2: [SW_HEPTAGON]
  },
  [ternaryToIndex('1020')]: {
    0: [NW_TRIANGLE, SE_TRAPEZOID],
    1: [NW_HEPTAGON],
    2: [NW_HEPTAGON]
  },
  [ternaryToIndex('2010')]: {
    0: [SE_TRIANGLE, NW_TRAPEZOID],
    1: [SE_HEPTAGON],
    2: [SE_HEPTAGON]
  },

  // 8-sided polygons based on mean weight
  [ternaryToIndex('2020')]: {
    0: [NW_TRAPEZOID, SE_TRAPEZOID],
    1: [OCTAGON],
    2: [SW_TRAPEZOID, NE_TRAPEZOID]
  },
  [ternaryToIndex('0202')]: {
    0: [NE_TRAPEZOID, SW_TRAPEZOID],
    1: [OCTAGON],
    2: [NW_TRAPEZOID, SE_TRAPEZOID]
  }
};


/***/ }),

/***/ "./src/contour-layer/marching-squares.js":
/*!***********************************************!*\
  !*** ./src/contour-layer/marching-squares.js ***!
  \***********************************************/
/*! exports provided: CONTOUR_TYPE, getCode, getVertices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONTOUR_TYPE", function() { return CONTOUR_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCode", function() { return getCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertices", function() { return getVertices; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _marching_squares_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./marching-squares-codes */ "./src/contour-layer/marching-squares-codes.js");
// All utility mehtods needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares




const CONTOUR_TYPE = {
  ISO_LINES: 1,
  ISO_BANDS: 2
};

const DEFAULT_THRESHOLD_DATA = {
  zIndex: 0,
  zOffset: 0.005
};

// Utility methods

function getVertexCode(weight, threshold) {
  // threshold must be a single value or a range (array of size 2)

  // Iso-bands
  if (Array.isArray(threshold)) {
    if (weight < threshold[0]) {
      return 0;
    }
    return weight < threshold[1] ? 1 : 2;
  }
  // Iso-lines
  return weight >= threshold ? 1 : 0;
}

// Returns marching square code for given cell
/* eslint-disable complexity, max-statements*/
function getCode(opts) {
  // Assumptions
  // Origin is on bottom-left , and X increase to right, Y to top
  // When processing one cell, we process 4 cells, by extending row to top and on column to right
  // to create a 2X2 cell grid
  const {cellWeights, x, y, width, height} = opts;
  let threshold = opts.threshold;
  if (opts.thresholdValue) {
    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].deprecated('thresholdValue', 'threshold')();
    threshold = opts.thresholdValue;
  }

  const isLeftBoundary = x < 0;
  const isRightBoundary = x >= width - 1;
  const isBottomBoundary = y < 0;
  const isTopBoundary = y >= height - 1;
  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;

  const weights = {};
  const codes = {};

  // TOP
  if (isLeftBoundary || isTopBoundary) {
    codes.top = 0;
  } else {
    weights.top = cellWeights[(y + 1) * width + x];
    codes.top = getVertexCode(weights.top, threshold);
  }

  // TOP-RIGHT
  if (isRightBoundary || isTopBoundary) {
    codes.topRight = 0;
  } else {
    weights.topRight = cellWeights[(y + 1) * width + x + 1];
    codes.topRight = getVertexCode(weights.topRight, threshold);
  }

  // RIGHT
  if (isRightBoundary || isBottomBoundary) {
    codes.right = 0;
  } else {
    weights.right = cellWeights[y * width + x + 1];
    codes.right = getVertexCode(weights.right, threshold);
  }

  // CURRENT
  if (isLeftBoundary || isBottomBoundary) {
    codes.current = 0;
  } else {
    weights.current = cellWeights[y * width + x];
    codes.current = getVertexCode(weights.current, threshold);
  }

  const {top, topRight, right, current} = codes;
  let code = -1;
  if (Number.isFinite(threshold)) {
    code = (top << 3) | (topRight << 2) | (right << 1) | current;
  }
  if (Array.isArray(threshold)) {
    code = (top << 6) | (topRight << 4) | (right << 2) | current;
  }

  let meanCode = 0;
  // meanCode is only needed for saddle cases, and they should
  // only occur when we are not processing a cell on boundary
  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes
  if (!isBoundary) {
    meanCode = getVertexCode(
      (weights.top + weights.topRight + weights.right + weights.current) / 4,
      threshold
    );
  }
  return {code, meanCode};
}
/* eslint-enable complexity, max-statements*/

// Returns intersection vertices for given cellindex
// [x, y] refers current marchng cell, reference vertex is always top-right corner
function getVertices(opts) {
  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;
  const thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);
  let offsets =
    type === CONTOUR_TYPE.ISO_BANDS
      ? _marching_squares_codes__WEBPACK_IMPORTED_MODULE_1__["ISOBANDS_CODE_OFFSET_MAP"][code]
      : _marching_squares_codes__WEBPACK_IMPORTED_MODULE_1__["ISOLINES_CODE_OFFSET_MAP"][code];

  // handle saddle cases
  if (!Array.isArray(offsets)) {
    offsets = offsets[meanCode];
  }

  // Reference vertex is at top-right move to top-right corner

  const vZ = thresholdData.zIndex * thresholdData.zOffset;
  const rX = (x + 1) * cellSize[0];
  const rY = (y + 1) * cellSize[1];

  const refVertexX = gridOrigin[0] + rX;
  const refVertexY = gridOrigin[1] + rY;

  // offsets format
  // ISO_LINES: [[1A, 1B], [2A, 2B]],
  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],

  // vertices format

  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],

  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format
  //      [
  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],
  //        ...
  //      ]

  if (type === CONTOUR_TYPE.ISO_BANDS) {
    const polygons = [];
    offsets.forEach(polygonOffsets => {
      const polygon = [];
      polygonOffsets.forEach(xyOffset => {
        const vX = refVertexX + xyOffset[0] * cellSize[0];
        const vY = refVertexY + xyOffset[1] * cellSize[1];
        polygon.push([vX, vY, vZ]);
      });
      polygons.push(polygon);
    });
    return polygons;
  }

  // default case is ISO_LINES
  const lines = [];
  offsets.forEach(xyOffsets => {
    xyOffsets.forEach(offset => {
      const vX = refVertexX + offset[0] * cellSize[0];
      const vY = refVertexY + offset[1] * cellSize[1];
      lines.push([vX, vY, vZ]);
    });
  });
  return lines;
}


/***/ }),

/***/ "./src/cpu-grid-layer/cpu-grid-layer.js":
/*!**********************************************!*\
  !*** ./src/cpu-grid-layer/cpu-grid-layer.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CPUGridLayer; });
/* harmony import */ var _deck_gl_layers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/layers */ "@deck.gl/core");
/* harmony import */ var _deck_gl_layers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_layers__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _grid_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grid-aggregator */ "./src/cpu-grid-layer/grid-aggregator.js");
/* harmony import */ var _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cpu-aggregator */ "./src/utils/cpu-aggregator.js");
/* harmony import */ var _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../aggregation-layer */ "./src/aggregation-layer.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.








function nop() {}

const defaultProps = {
  // color
  colorDomain: null,
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_1__["defaultColorRange"],
  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`
  getColorWeight: {type: 'accessor', value: x => 1},
  colorAggregation: 'SUM',
  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},
  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},
  colorScaleType: 'quantize',
  onSetColorDomain: nop,

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`
  getElevationWeight: {type: 'accessor', value: x => 1},
  elevationAggregation: 'SUM',
  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},
  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},
  elevationScale: {type: 'number', min: 0, value: 1},
  elevationScaleType: 'linear',
  onSetElevationDomain: nop,

  gridAggregator: _grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["pointToDensityGridDataCPU"],

  // grid
  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},
  coverage: {type: 'number', min: 0, max: 1, value: 1},
  getPosition: {type: 'accessor', value: x => x.position},
  extruded: false,

  // Optional material for 'lighting' shader module
  material: true,

  // data filter
  _filterData: {type: 'function', value: null, optional: true}
};

class CPUGridLayer extends _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__["default"] {
  initializeState() {
    const cpuAggregator = new _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_3__["default"]({
      getAggregator: props => props.gridAggregator,
      getCellSize: props => props.cellSize
    });

    this.state = {
      cpuAggregator,
      aggregatorState: cpuAggregator.state
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {size: 3, accessor: 'getPosition'}
    });
    // color and elevation attributes can't be added as attributes
    // they are calcualted using 'getValue' accessor that takes an array of pints.
  }

  updateState(opts) {
    super.updateState(opts);
    this.setState({
      // make a copy of the internal state of cpuAggregator for testing
      aggregatorState: this.state.cpuAggregator.updateState(opts, {
        viewport: this.context.viewport,
        attributes: this.getAttributes(),
        numInstances: this.getNumInstances(opts.props)
      })
    });
  }

  getPickingInfo({info}) {
    return this.state.cpuAggregator.getPickingInfo({info});
  }

  // create a method for testing
  _onGetSublayerColor(cell) {
    return this.state.cpuAggregator.getAccessor('fillColor')(cell);
  }

  // create a method for testing
  _onGetSublayerElevation(cell) {
    return this.state.cpuAggregator.getAccessor('elevation')(cell);
  }

  _getSublayerUpdateTriggers() {
    return this.state.cpuAggregator.getUpdateTriggers(this.props);
  }

  renderLayers() {
    const {elevationScale, extruded, cellSize, coverage, material, transitions} = this.props;
    const {cpuAggregator} = this.state;
    const SubLayerClass = this.getSubLayerClass('grid-cell', _deck_gl_layers__WEBPACK_IMPORTED_MODULE_0__["GridCellLayer"]);
    const updateTriggers = this._getSublayerUpdateTriggers();

    return new SubLayerClass(
      {
        cellSize,
        coverage,
        material,
        elevationScale,
        extruded,

        getFillColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        transitions: transitions && {
          getFillColor: transitions.getColorValue || transitions.getColorWeight,
          getElevation: transitions.getElevationValue || transitions.getElevationWeight
        }
      },
      this.getSubLayerProps({
        id: 'grid-cell',
        updateTriggers
      }),
      {
        data: cpuAggregator.state.layerData.data
      }
    );
  }
}

CPUGridLayer.layerName = 'CPUGridLayer';
CPUGridLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/cpu-grid-layer/grid-aggregator.js":
/*!***********************************************!*\
  !*** ./src/cpu-grid-layer/grid-aggregator.js ***!
  \***********************************************/
/*! exports provided: pointToDensityGridDataCPU */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointToDensityGridDataCPU", function() { return pointToDensityGridDataCPU; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grid-aggregation-utils */ "./src/utils/grid-aggregation-utils.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




/**
 * Calculate density grid from an array of points
 * @param {Object} props - object containing :
 * @param {Iterable} [props.data] - data objects to be aggregated
 * @param {Integer} [props.cellSize] - size of the grid cell
 *
 * @param {Object} aggregationParams - object containing :
 * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters
 * @param {Integer} width - width of the grid
 * @param {Integer} height - height of the grid
 * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise
 * @param {Array} attributes - attributes array containing position values
 * @param {Viewport} viewport - viewport to be used for projection
 * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index
 * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data
 *
 * @returns {object} - grid data, cell dimension
 */
function pointToDensityGridDataCPU(props, aggregationParams) {
  const hashInfo = pointsToGridHashing(props, aggregationParams);
  const result = getGridLayerDataFromGridHash(hashInfo);

  return {
    gridHash: hashInfo.gridHash,
    gridOffset: hashInfo.gridOffset,
    data: result
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {Iterable} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
/* eslint-disable max-statements, complexity */
function pointsToGridHashing(props, aggregationParams) {
  const {data = [], cellSize} = props;
  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;
  const positions = attributes.positions.value;
  const {size} = attributes.positions.getAccessor();
  const boundingBox =
    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);
  const offsets = aggregationParams.posOffset || [180, 90];
  const gridOffset = aggregationParams.gridOffset || Object(_utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_1__["getGridOffset"])(boundingBox, cellSize);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return {gridHash: {}, gridOffset};
  }

  const {width, height} = viewport;
  const numCol = Math.ceil(width / gridOffset.xOffset);
  const numRow = Math.ceil(height / gridOffset.yOffset);

  // calculate count per cell
  const gridHash = {};

  const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data);
  const position = new Array(3);
  for (const pt of iterable) {
    objectInfo.index++;
    position[0] = positions[objectInfo.index * size];
    position[1] = positions[objectInfo.index * size + 1];
    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;
    const [x, y] = projectPoints ? viewport.project(position) : position;
    if (Number.isFinite(x) && Number.isFinite(y)) {
      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);
      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);
      if (
        !projectPoints ||
        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.
        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)
      ) {
        const key = `${yIndex}-${xIndex}`;

        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};
        gridHash[key].count += 1;
        gridHash[key].points.push(pt);
      }
    }
  }

  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};
}
/* eslint-enable max-statements, complexity */

function getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {
  const data = new Array(Object.keys(gridHash).length);
  let i = 0;
  for (const key in gridHash) {
    const idxs = key.split('-');
    const latIdx = parseInt(idxs[0], 10);
    const lonIdx = parseInt(idxs[1], 10);
    const index = i++;

    data[index] = Object.assign(
      {
        index,
        position: [
          offsets[0] + gridOffset.xOffset * lonIdx,
          offsets[1] + gridOffset.yOffset * latIdx
        ]
      },
      gridHash[key]
    );
  }
  return data;
}

// Calculate bounding box of position attribute
function getPositionBoundingBox(positionAttribute, numInstance) {
  // TODO - value might not exist (e.g. attribute transition)
  const positions = positionAttribute.value;
  const {size} = positionAttribute.getAccessor();

  let yMin = Infinity;
  let yMax = -Infinity;
  let xMin = Infinity;
  let xMax = -Infinity;
  let y;
  let x;

  for (let i = 0; i < numInstance; i++) {
    x = positions[i * size];
    y = positions[i * size + 1];
    if (Number.isFinite(x) && Number.isFinite(y)) {
      yMin = y < yMin ? y : yMin;
      yMax = y > yMax ? y : yMax;
      xMin = x < xMin ? x : xMin;
      xMax = x > xMax ? x : xMax;
    }
  }

  return {xMin, xMax, yMin, yMax};
}


/***/ }),

/***/ "./src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js":
/*!*****************************************************************!*\
  !*** ./src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;
  fragColor = picking_filterColor(fragColor);
}
`);


/***/ }),

/***/ "./src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js":
/*!***************************************************************!*\
  !*** ./src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Inspired by screen-grid-layer vertex shader in deck.gl

/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6

in vec3 positions;
in vec3 normals;

in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;

// Custom uniforms
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;

uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;

// Domain uniforms
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;

layout(std140) uniform;
uniform ColorData
{
  vec4 maxMinCount;
} colorData;
uniform ElevationData
{
  vec4 maxMinCount;
} elevationData;

#define EPSILON 0.00001

// Result
out vec4 vColor;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  return outColor;
}

float linearScale(vec2 domain, vec2 range, float value) {
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
  }
  return -1.;
}

void main(void) {

  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);

  float elevation = 0.0;

  if (extruded) {
    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
    elevation = linearScale(elvDomain, elevationRange, elevations.r);
    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
  }

  // if aggregated color or elevation is 0 do not render
  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
  float dotRadius = cellSize / 2. * coverage * shouldRender;

  int yIndex = (gl_InstanceID / gridSize[0]);
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));

  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  vec4 position_commonspace;
  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, position_commonspace);

  // Light calculations
  // Worldspace is the linear space after Mercator projection

  vec3 normals_commonspace = project_normal(normals);

   if (extruded) {
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);
    vColor = vec4(lightColor, color.a * opacity) / 255.;
  } else {
    vColor = vec4(color.rgb, color.a * opacity) / 255.;
  }
}
`);


/***/ }),

/***/ "./src/gpu-grid-layer/gpu-grid-cell-layer.js":
/*!***************************************************!*\
  !*** ./src/gpu-grid-layer/gpu-grid-cell-layer.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GPUGridCellLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _gpu_grid_cell_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gpu-grid-cell-layer-vertex.glsl */ "./src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js");
/* harmony import */ var _gpu_grid_cell_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gpu-grid-cell-layer-fragment.glsl */ "./src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.









const COLOR_DATA_UBO_INDEX = 0;
const ELEVATION_DATA_UBO_INDEX = 1;

const defaultProps = {
  // color
  colorDomain: null,
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_2__["defaultColorRange"],

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  elevationScale: {type: 'number', min: 0, value: 1},

  // grid
  gridSize: {type: 'array', min: 0, value: [1, 1]},
  gridOrigin: {type: 'array', min: 0, value: [0, 0]},
  gridOffset: {type: 'array', min: 0, value: [0, 0]},

  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},
  offset: {type: 'array', min: 0, value: [1, 1]},
  coverage: {type: 'number', min: 0, max: 1, value: 1},
  extruded: true,

  material: true // Use lighting module defaults
};

class GPUGridCellLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    return super.getShaders({
      vs: _gpu_grid_cell_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__["default"],
      fs: _gpu_grid_cell_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__["default"],
      modules: [_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["project32"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["gouraudLighting"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["picking"], _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"]]
    });
  }

  initializeState() {
    const {gl} = this.context;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      colors: {
        size: 4,
        noAlloc: true
      },
      elevations: {
        size: 4,
        noAlloc: true
      }
    });
    const model = this._getModel(gl);
    this._setupUniformBuffer(model);
    this.setState({model});
  }

  _getModel(gl) {
    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["CubeGeometry"](),
        isInstanced: true
      })
    );
  }

  draw({uniforms}) {
    const {
      cellSize,
      offset,
      extruded,
      elevationScale,
      coverage,
      gridSize,
      gridOrigin,
      gridOffset,
      elevationRange,
      colorMaxMinBuffer,
      elevationMaxMinBuffer
    } = this.props;

    const gridOriginLow = [Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"])(gridOrigin[0]), Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"])(gridOrigin[1])];
    const gridOffsetLow = [Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"])(gridOffset[0]), Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"])(gridOffset[1])];
    const domainUniforms = this.getDomainUniforms();
    const colorRange = Object(_utils_color_utils__WEBPACK_IMPORTED_MODULE_2__["colorRangeToFlatArray"])(this.props.colorRange);
    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, domainUniforms, {
          cellSize,
          offset,
          extruded,
          elevationScale,
          coverage,
          gridSize,
          gridOrigin,
          gridOriginLow,
          gridOffset,
          gridOffsetLow,
          colorRange,
          elevationRange
        })
      )
      .draw();
    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
  }

  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
    colorMaxMinBuffer.bind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});
    elevationMaxMinBuffer.bind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});
  }

  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
    colorMaxMinBuffer.unbind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});
    elevationMaxMinBuffer.unbind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});
  }

  getDomainUniforms() {
    const {colorDomain, elevationDomain} = this.props;
    const domainUniforms = {};
    if (colorDomain !== null) {
      domainUniforms.colorDomainValid = true;
      domainUniforms.colorDomain = colorDomain;
    } else {
      domainUniforms.colorDomainValid = false;
    }
    if (elevationDomain !== null) {
      domainUniforms.elevationDomainValid = true;
      domainUniforms.elevationDomain = elevationDomain;
    } else {
      domainUniforms.elevationDomainValid = false;
    }
    return domainUniforms;
  }

  _setupUniformBuffer(model) {
    const gl = this.context.gl;
    const programHandle = model.program.handle;

    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');
    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');
    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);
    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);
  }
}

GPUGridCellLayer.layerName = 'GPUGridCellLayer';
GPUGridCellLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/gpu-grid-layer/gpu-grid-layer.js":
/*!**********************************************!*\
  !*** ./src/gpu-grid-layer/gpu-grid-layer.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GPUGridLayer; });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony import */ var _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _gpu_grid_cell_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gpu-grid-cell-layer */ "./src/gpu-grid-layer/gpu-grid-cell-layer.js");
/* harmony import */ var _cpu_grid_layer_grid_aggregator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../cpu-grid-layer/grid-aggregator */ "./src/cpu-grid-layer/grid-aggregator.js");
/* harmony import */ var _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../grid-aggregation-layer */ "./src/grid-aggregation-layer.js");
/* harmony import */ var _utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/grid-aggregation-utils */ "./src/utils/grid-aggregation-utils.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.













const defaultProps = {
  // color
  colorDomain: null,
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_4__["defaultColorRange"],
  getColorWeight: {type: 'accessor', value: x => 1},
  colorAggregation: 'SUM',

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationWeight: {type: 'accessor', value: x => 1},
  elevationAggregation: 'SUM',
  elevationScale: {type: 'number', min: 0, value: 1},

  // grid
  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},
  coverage: {type: 'number', min: 0, max: 1, value: 1},
  getPosition: {type: 'accessor', value: x => x.position},
  extruded: false,

  // Optional material for 'lighting' shader module
  material: true
};

// This layer only perform GPU aggregation, no need to seperate data and weight props
// aggregation will be dirty when any of the props are changed.

const DIMENSIONS = {
  data: {
    props: ['cellSize', 'colorAggregation', 'elevationAggregation']
  }
  // rest of the changes are detected by `state.attributesChanged`
};
const POSITION_ATTRIBUTE_NAME = 'positions';

class GPUGridLayer extends _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_7__["default"] {
  initializeState() {
    const {gl} = this.context;
    const isSupported = _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"].isSupported(gl);
    if (!isSupported) {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["log"].error('GPUGridLayer is not supported on this browser, use GridLayer instead')();
    }
    super.initializeState({
      dimensions: DIMENSIONS
    });
    this.setState({
      gpuAggregation: true,
      projectPoints: false, // aggregation in world space
      isSupported,
      weights: {
        color: {
          needMin: true,
          needMax: true,
          combineMaxMin: true,
          maxMinBuffer: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
            byteLength: 4 * 4,
            accessor: {size: 4, type: _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT, divisor: 1}
          })
        },
        elevation: {
          needMin: true,
          needMax: true,
          combineMaxMin: true,
          maxMinBuffer: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
            byteLength: 4 * 4,
            accessor: {size: 4, type: _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT, divisor: 1}
          })
        }
      },
      positionAttributeName: 'positions'
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME]: {
        size: 3,
        accessor: 'getPosition',
        type: _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default.a.DOUBLE,
        fp64: this.use64bitPositions()
      },
      color: {size: 3, accessor: 'getColorWeight'},
      elevation: {size: 3, accessor: 'getElevationWeight'}
    });
  }

  updateState(opts) {
    if (this.state.isSupported === false) {
      // Skip update, layer not supported
      return;
    }
    super.updateState(opts);
    const {aggregationDirty} = this.state;
    if (aggregationDirty) {
      // reset cached CPU Aggregation results (used for picking)
      this.setState({
        gridHash: null
      });
    }
  }

  getHashKeyForIndex(index) {
    const {numRow, numCol, boundingBox, gridOffset} = this.state;
    const gridSize = [numCol, numRow];
    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];

    const yIndex = Math.floor(index / gridSize[0]);
    const xIndex = index - yIndex * gridSize[0];
    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.
    const latIdx = Math.floor(
      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]
    );
    const lonIdx = Math.floor(
      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]
    );
    return `${latIdx}-${lonIdx}`;
  }

  getPositionForIndex(index) {
    const {numRow, numCol, boundingBox, gridOffset} = this.state;
    const gridSize = [numCol, numRow];
    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];

    const yIndex = Math.floor(index / gridSize[0]);
    const xIndex = index - yIndex * gridSize[0];
    const yPos = yIndex * cellSize[1] + gridOrigin[1];
    const xPos = xIndex * cellSize[0] + gridOrigin[0];
    return [xPos, yPos];
  }

  getPickingInfo({info, mode}) {
    const {index} = info;
    let object = null;
    if (index >= 0) {
      const {gpuGridAggregator} = this.state;
      const position = this.getPositionForIndex(index);
      const colorInfo = _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"].getAggregationData(
        Object.assign({pixelIndex: index}, gpuGridAggregator.getData('color'))
      );
      const elevationInfo = _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"].getAggregationData(
        Object.assign({pixelIndex: index}, gpuGridAggregator.getData('elevation'))
      );

      object = {
        colorValue: colorInfo.cellWeight,
        elevationValue: elevationInfo.cellWeight,
        count: colorInfo.cellCount || elevationInfo.cellCount,
        position,
        totalCount: colorInfo.totalCount || elevationInfo.totalCount
      };
      if (mode !== 'hover') {
        // perform CPU aggregation for full list of points for each cell
        const {props} = this;
        let {gridHash} = this.state;
        if (!gridHash) {
          const {gridOffset, translation, boundingBox} = this.state;
          const {viewport} = this.context;
          const attributes = this.getAttributes();
          const cpuAggregation = Object(_cpu_grid_layer_grid_aggregator__WEBPACK_IMPORTED_MODULE_6__["pointToDensityGridDataCPU"])(props, {
            gridOffset,
            attributes,
            viewport,
            translation,
            boundingBox
          });
          gridHash = cpuAggregation.gridHash;
          this.setState({gridHash});
        }
        const key = this.getHashKeyForIndex(index);
        const cpuAggregationData = gridHash[key];
        Object.assign(object, cpuAggregationData);
      }
    }

    return Object.assign(info, {
      picked: Boolean(object),
      // override object with picked cell
      object
    });
  }

  renderLayers() {
    if (!this.state.isSupported) {
      return null;
    }
    const {
      elevationScale,
      extruded,
      cellSize: cellSizeMeters,
      coverage,
      material,
      elevationRange,
      colorDomain,
      elevationDomain
    } = this.props;

    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;
    const {color, elevation} = weights;
    const colorRange = Object(_utils_color_utils__WEBPACK_IMPORTED_MODULE_4__["colorRangeToFlatArray"])(this.props.colorRange);

    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', _gpu_grid_cell_layer__WEBPACK_IMPORTED_MODULE_5__["default"]);

    return new SubLayerClass(
      {
        gridSize: [numCol, numRow],
        gridOrigin,
        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],
        colorRange,
        elevationRange,
        colorDomain,
        elevationDomain,

        cellSize: cellSizeMeters,
        coverage,
        material,
        elevationScale,
        extruded
      },
      this.getSubLayerProps({
        id: 'gpu-grid-cell'
      }),
      {
        data: {
          attributes: {
            colors: color.aggregationBuffer,
            elevations: elevation.aggregationBuffer
          }
        },
        colorMaxMinBuffer: color.maxMinBuffer,
        elevationMaxMinBuffer: elevation.maxMinBuffer,
        numInstances: numCol * numRow
      }
    );
  }

  finalizeState() {
    const {color, elevation} = this.state.weights;
    [color, elevation].forEach(weight => {
      const {aggregationBuffer, maxMinBuffer} = weight;
      maxMinBuffer.delete();
      if (aggregationBuffer) {
        aggregationBuffer.delete();
      }
    });
    super.finalizeState();
  }

  // Aggregation Overrides

  updateAggregationState(opts) {
    const {props, oldProps} = opts;
    const {cellSize, coordinateSystem} = props;
    const {viewport} = this.context;
    const cellSizeChanged = oldProps.cellSize !== cellSize;
    const {dimensions} = this.state;

    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);
    // any attribute changed
    const attributesChanged = positionsChanged || this.isAttributeChanged();

    let {boundingBox} = this.state;
    if (positionsChanged) {
      boundingBox = Object(_utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_8__["getBoundingBox"])(this.getAttributes(), this.getNumInstances());
      this.setState({boundingBox});
    }
    if (positionsChanged || cellSizeChanged) {
      const {gridOffset, translation, width, height, numCol, numRow} = Object(_utils_grid_aggregation_utils__WEBPACK_IMPORTED_MODULE_8__["getGridParams"])(
        boundingBox,
        cellSize,
        viewport,
        coordinateSystem
      );
      this.allocateResources(numRow, numCol);
      this.setState({
        gridOffset,
        translation,
        gridOrigin: [-1 * translation[0], -1 * translation[1]],
        width,
        height,
        numCol,
        numRow
      });
    }

    const aggregationDataDirty =
      attributesChanged ||
      this.isAggregationDirty(opts, {
        dimension: dimensions.data,
        compareAll: true
      });

    if (aggregationDataDirty) {
      this._updateAccessors(opts);
    }
    this.setState({
      aggregationDataDirty
    });
  }

  // Private

  _updateAccessors(opts) {
    const {colorAggregation, elevationAggregation} = opts.props;
    const {color, elevation} = this.state.weights;
    color.operation = _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"][colorAggregation];
    elevation.operation = _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"][elevationAggregation];
  }
}

GPUGridLayer.layerName = 'GPUGridLayer';
GPUGridLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/grid-aggregation-layer.js":
/*!***************************************!*\
  !*** ./src/grid-aggregation-layer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridAggregationLayer; });
/* harmony import */ var _aggregation_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aggregation-layer */ "./src/aggregation-layer.js");
/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils_bin_sorter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/bin-sorter */ "./src/utils/bin-sorter.js");
/* harmony import */ var _cpu_grid_layer_grid_aggregator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cpu-grid-layer/grid-aggregator */ "./src/cpu-grid-layer/grid-aggregator.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.









class GridAggregationLayer extends _aggregation_layer__WEBPACK_IMPORTED_MODULE_0__["default"] {
  initializeState({dimensions}) {
    const {gl} = this.context;
    super.initializeState(dimensions);
    this.setState({
      // CPU aggregation results
      layerData: {},
      gpuGridAggregator: new _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_1__["default"](gl, {id: `${this.id}-gpu-aggregator`}),
      cpuGridAggregator: _cpu_grid_layer_grid_aggregator__WEBPACK_IMPORTED_MODULE_5__["pointToDensityGridDataCPU"]
    });
  }

  updateState(opts) {
    // get current attributes
    super.updateState(opts);

    this.updateAggregationState(opts);

    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;
    if (this.getNumInstances() <= 0) {
      return;
    }
    let aggregationDirty = false;
    // CPU aggregation is two steps
    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin
    // For GPU aggregation both above steps are combined into one step

    // step-1
    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {
      this._updateAggregation(opts);
      aggregationDirty = true;
    }
    // step-2 (Applicalbe for CPU aggregation only)
    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {
      this._updateWeightBins();
      this._uploadAggregationResults();
      aggregationDirty = true;
    }

    this.setState({aggregationDirty});
  }

  finalizeState() {
    const {count} = this.state.weights;
    if (count && count.aggregationBuffer) {
      count.aggregationBuffer.delete();
    }
    const {gpuGridAggregator} = this.state;
    if (gpuGridAggregator) {
      gpuGridAggregator.delete();
    }
    super.finalizeState();
  }

  updateShaders(shaders) {
    if (this.state.gpuAggregation) {
      this.state.gpuGridAggregator.updateShaders(shaders);
    }
  }

  // Methods that can be overriden by subclasses for customizations

  updateAggregationState(opts) {
    // Sublayers should implement this method.
    _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__["log"].assert(false);
  }

  allocateResources(numRow, numCol) {
    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {
      const dataBytes = numCol * numRow * 4 * 4;
      const gl = this.context.gl;
      const {weights} = this.state;
      for (const name in weights) {
        const weight = weights[name];
        if (weight.aggregationBuffer) {
          weight.aggregationBuffer.delete();
        }
        weight.aggregationBuffer = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Buffer"](gl, {
          byteLength: dataBytes,
          accessor: {
            size: 4,
            type: _luma_gl_core__WEBPACK_IMPORTED_MODULE_2___default.a.FLOAT,
            divisor: 1
          }
        });
      }
    }
  }

  updateResults({aggregationData, maxMinData, maxData, minData}) {
    const {count} = this.state.weights;
    if (count) {
      count.aggregationData = aggregationData;
      count.maxMinData = maxMinData;
      count.maxData = maxData;
      count.minData = minData;
    }
  }

  // Private

  _updateAggregation(opts) {
    const {
      cpuGridAggregator,
      gpuGridAggregator,
      gridOffset,
      posOffset,
      translation = [0, 0],
      scaling = [0, 0, 0],
      boundingBox,
      projectPoints,
      gpuAggregation,
      numCol,
      numRow
    } = this.state;
    const {props} = opts;
    const {viewport} = this.context;
    const attributes = this.getAttributes();
    const vertexCount = this.getNumInstances();

    if (!gpuAggregation) {
      const result = cpuGridAggregator(props, {
        gridOffset,
        projectPoints,
        attributes,
        viewport,
        posOffset,
        boundingBox
      });
      this.setState({
        layerData: result
      });
    } else {
      const {weights} = this.state;
      gpuGridAggregator.run({
        weights,
        cellSize: [gridOffset.xOffset, gridOffset.yOffset],
        numCol,
        numRow,
        translation,
        scaling,
        vertexCount,
        projectPoints,
        attributes,
        moduleSettings: this.getModuleSettings()
      });
    }
  }

  _updateWeightBins() {
    const {getValue} = this.state;

    const sortedBins = new _utils_bin_sorter__WEBPACK_IMPORTED_MODULE_4__["default"](this.state.layerData.data || [], {getValue});
    this.setState({sortedBins});
  }

  _uploadAggregationResults() {
    const {numCol, numRow} = this.state;
    const {data} = this.state.layerData;
    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins;

    const ELEMENTCOUNT = 4;
    const aggregationSize = numCol * numRow * ELEMENTCOUNT;
    const aggregationData = new Float32Array(aggregationSize).fill(0);
    for (const bin of aggregatedBins) {
      const {lonIdx, latIdx} = data[bin.i];
      const {value, counts} = bin;
      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;
      aggregationData[cellIndex] = value;
      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;
    }
    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);
    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);
    const minData = new Float32Array([minValue, 0, 0, totalCount]);
    this.updateResults({aggregationData, maxMinData, maxData, minData});
  }
}

GridAggregationLayer.layerName = 'GridAggregationLayer';


/***/ }),

/***/ "./src/grid-layer/grid-layer.js":
/*!**************************************!*\
  !*** ./src/grid-layer/grid-layer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony import */ var _gpu_grid_layer_gpu_grid_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gpu-grid-layer/gpu-grid-layer */ "./src/gpu-grid-layer/gpu-grid-layer.js");
/* harmony import */ var _cpu_grid_layer_cpu_grid_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cpu-grid-layer/cpu-grid-layer */ "./src/cpu-grid-layer/cpu-grid-layer.js");





const defaultProps = Object.assign({}, _gpu_grid_layer_gpu_grid_layer__WEBPACK_IMPORTED_MODULE_2__["default"].defaultProps, _cpu_grid_layer_cpu_grid_layer__WEBPACK_IMPORTED_MODULE_3__["default"].defaultProps, {
  gpuAggregation: false
});

class GridLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["CompositeLayer"] {
  initializeState() {
    this.state = {
      useGPUAggregation: true
    };
  }

  updateState({oldProps, props, changeFlags}) {
    const newState = {};
    newState.useGPUAggregation = this.canUseGPUAggregation(props);
    this.setState(newState);
  }

  renderLayers() {
    const {data, updateTriggers} = this.props;
    const id = this.state.useGPUAggregation ? 'GPU' : 'CPU';
    const LayerType = this.state.useGPUAggregation
      ? this.getSubLayerClass('GPU', _gpu_grid_layer_gpu_grid_layer__WEBPACK_IMPORTED_MODULE_2__["default"])
      : this.getSubLayerClass('CPU', _cpu_grid_layer_cpu_grid_layer__WEBPACK_IMPORTED_MODULE_3__["default"]);
    return new LayerType(
      this.props,
      this.getSubLayerProps({
        id,
        updateTriggers
      }),
      {
        data
      }
    );
  }

  // Private methods

  canUseGPUAggregation(props) {
    const {
      gpuAggregation,
      lowerPercentile,
      upperPercentile,
      getColorValue,
      getElevationValue,
      colorScaleType
    } = props;
    if (!gpuAggregation) {
      // cpu aggregation is requested
      return false;
    }
    if (!_utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_1__["default"].isSupported(this.context.gl)) {
      return false;
    }
    if (lowerPercentile !== 0 || upperPercentile !== 100) {
      // percentile calculations requires sorting not supported on GPU
      return false;
    }
    if (getColorValue !== null || getElevationValue !== null) {
      // accessor for custom color or elevation calculation is specified
      return false;
    }
    if (colorScaleType === 'quantile' || colorScaleType === 'ordinal') {
      // quantile and ordinal scales are not supported on GPU
      return false;
    }
    return true;
  }
}

GridLayer.layerName = 'GridLayer';
GridLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/heatmap-layer/heatmap-layer-utils.js":
/*!**************************************************!*\
  !*** ./src/heatmap-layer/heatmap-layer-utils.js ***!
  \**************************************************/
/*! exports provided: getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates, getTextureParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBounds", function() { return getBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsContain", function() { return boundsContain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "packVertices", function() { return packVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleToAspectRatio", function() { return scaleToAspectRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextureCoordinates", function() { return getTextureCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextureParams", function() { return getTextureParams; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);



function getBounds(points) {
  // Now build bounding box in world space (aligned to world coordiante system)
  const x = points.map(p => p[0]);
  const y = points.map(p => p[1]);

  const xMin = Math.min.apply(null, x);
  const xMax = Math.max.apply(null, x);
  const yMin = Math.min.apply(null, y);
  const yMax = Math.max.apply(null, y);

  return [xMin, yMin, xMax, yMax];
}

// true if currentBounds contains targetBounds, false otherwise
function boundsContain(currentBounds, targetBounds) {
  if (
    targetBounds[0] >= currentBounds[0] &&
    targetBounds[2] <= currentBounds[2] &&
    targetBounds[1] >= currentBounds[1] &&
    targetBounds[3] <= currentBounds[3]
  ) {
    return true;
  }
  return false;
}

const scratchArray = new Float32Array(12);

// For given rectangle bounds generates two triangles vertices that coverit completely
function packVertices(points, dimensions = 2) {
  let index = 0;
  for (const point of points) {
    for (let i = 0; i < dimensions; i++) {
      scratchArray[index++] = point[i] || 0;
    }
  }
  return scratchArray;
}

// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height
function scaleToAspectRatio(boundingBox, width, height) {
  const [xMin, yMin, xMax, yMax] = boundingBox;

  const currentWidth = xMax - xMin;
  const currentHeight = yMax - yMin;

  let newWidth = currentWidth;
  let newHeight = currentHeight;
  if (currentWidth / currentHeight < width / height) {
    // expand bounding box width
    newWidth = (width / height) * currentHeight;
  } else {
    newHeight = (height / width) * currentWidth;
  }

  if (newWidth < width) {
    newWidth = width;
    newHeight = height;
  }

  const xCenter = (xMax + xMin) / 2;
  const yCenter = (yMax + yMin) / 2;

  return [
    xCenter - newWidth / 2,
    yCenter - newHeight / 2,
    xCenter + newWidth / 2,
    yCenter + newHeight / 2
  ];
}

// Get texture coordiante of point inside a bounding box
function getTextureCoordinates(point, bounds) {
  const [xMin, yMin, xMax, yMax] = bounds;
  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
}

// Returns format and type for creating texture objects
function getTextureParams({gl, floatTargetSupport}) {
  return {
    // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures
    format: Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    type: floatTargetSupport ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE
  };
}


/***/ }),

/***/ "./src/heatmap-layer/heatmap-layer.js":
/*!********************************************!*\
  !*** ./src/heatmap-layer/heatmap-layer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HeatmapLayer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./heatmap-layer-utils */ "./src/heatmap-layer/heatmap-layer-utils.js");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _triangle_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./triangle-layer */ "./src/heatmap-layer/triangle-layer.js");
/* harmony import */ var _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../aggregation-layer */ "./src/aggregation-layer.js");
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _weights_vs_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./weights-vs.glsl */ "./src/heatmap-layer/weights-vs.glsl.js");
/* harmony import */ var _weights_fs_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./weights-fs.glsl */ "./src/heatmap-layer/weights-fs.glsl.js");
/* harmony import */ var _max_vs_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./max-vs.glsl */ "./src/heatmap-layer/max-vs.glsl.js");
// Copyright (c) 2015 - 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global setTimeout clearTimeout */











const RESOLUTION = 2; // (number of common space pixels) / (number texels)
const SIZE_2K = 2048;
const ZOOM_DEBOUNCE = 500; // milliseconds
const TEXTURE_OPTIONS = {
  mipmaps: false,
  parameters: {
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE,
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE
  },
  dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA
};
const DEFAULT_COLOR_DOMAIN = [0, 0];

const defaultProps = {
  getPosition: {type: 'accessor', value: x => x.position},
  getWeight: {type: 'accessor', value: 1},
  intensity: {type: 'number', min: 0, value: 1},
  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_5__["defaultColorRange"],
  threshold: {type: 'number', min: 0, max: 1, value: 0.05},
  colorDomain: {type: 'array', value: null, optional: true}
};

const REQUIRED_FEATURES = [
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].BLEND_EQUATION_MINMAX, // max weight calculation
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].TEXTURE_FLOAT // weight-map as texture
  // FEATURES.FLOAT_BLEND, // implictly supported when TEXTURE_FLOAT is supported
];

const DIMENSIONS = {
  data: {
    props: ['radiusPixels']
  }
};

class HeatmapLayer extends _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__["default"] {
  initializeState() {
    const {gl} = this.context;
    if (!Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, REQUIRED_FEATURES)) {
      this.setState({supported: false});
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["log"].error(`HeatmapLayer: ${this.id} is not supported on this browser`)();
      return;
    }
    super.initializeState(DIMENSIONS);
    this.setState({supported: true});
    this._setupTextureParams();
    this._setupAttributes();
    this._setupResources();
  }

  shouldUpdateState({changeFlags}) {
    // Need to be updated when viewport changes
    return changeFlags.somethingChanged;
  }

  /* eslint-disable complexity */
  updateState(opts) {
    if (!this.state.supported) {
      return;
    }
    super.updateState(opts);
    const {props, oldProps} = opts;
    const changeFlags = this._getChangeFlags(opts);

    if (changeFlags.viewportChanged) {
      changeFlags.boundsChanged = this._updateBounds();
    }

    if (changeFlags.dataChanged || changeFlags.boundsChanged) {
      this._updateWeightmap();
    } else if (changeFlags.viewportZoomChanged) {
      this._debouncedUpdateWeightmap();
    }

    if (props.colorRange !== oldProps.colorRange) {
      this._updateColorTexture(opts);
    }

    if (changeFlags.viewportChanged) {
      this._updateTextureRenderingBounds();
    }

    if (oldProps.colorDomain !== props.colorDomain || changeFlags.viewportChanged) {
      const {viewport} = this.context;
      const {weightsScale} = this.state;
      const domainScale = (viewport ? 1024 / viewport.scale : 1) * weightsScale;
      const colorDomain = props.colorDomain
        ? props.colorDomain.map(x => x * domainScale)
        : DEFAULT_COLOR_DOMAIN;
      if (colorDomain[1] > 0 && weightsScale < 1) {
        // Hack - when low precision texture is used, aggregated weights are in the [0, 1]
        // range. Scale colorDomain to fit.
        const max = Math.min(colorDomain[1], 1);
        colorDomain[0] *= max / colorDomain[1];
        colorDomain[1] = max;
      }
      this.setState({colorDomain});
    }

    this.setState({zoom: opts.context.viewport.zoom});
  }
  /* eslint-enable complexity */

  renderLayers() {
    if (!this.state.supported) {
      return [];
    }
    const {
      weightsTexture,
      triPositionBuffer,
      triTexCoordBuffer,
      maxWeightsTexture,
      colorTexture,
      colorDomain
    } = this.state;
    const {updateTriggers, intensity, threshold} = this.props;

    const TriangleLayerClass = this.getSubLayerClass('triangle', _triangle_layer__WEBPACK_IMPORTED_MODULE_3__["default"]);

    return new TriangleLayerClass(
      this.getSubLayerProps({
        id: 'triangle-layer',
        updateTriggers
      }),
      {
        data: {
          attributes: {
            positions: triPositionBuffer,
            texCoords: triTexCoordBuffer
          }
        },
        vertexCount: 4,
        maxTexture: maxWeightsTexture,
        colorTexture,
        texture: weightsTexture,
        intensity,
        threshold,
        colorDomain
      }
    );
  }

  finalizeState() {
    super.finalizeState();
    const {
      weightsTransform,
      weightsTexture,
      maxWeightTransform,
      maxWeightsTexture,
      triPositionBuffer,
      triTexCoordBuffer,
      colorTexture,
      updateTimer
    } = this.state;
    /* eslint-disable no-unused-expressions */
    weightsTransform && weightsTransform.delete();
    weightsTexture && weightsTexture.delete();
    maxWeightTransform && maxWeightTransform.delete();
    maxWeightsTexture && maxWeightsTexture.delete();
    triPositionBuffer && triPositionBuffer.delete();
    triTexCoordBuffer && triTexCoordBuffer.delete();
    colorTexture && colorTexture.delete();
    updateTimer && clearTimeout(updateTimer);
    /* eslint-enable no-unused-expressions */
  }

  // PRIVATE

  // override Composite layer private method to create AttributeManager instance
  _getAttributeManager() {
    return new _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["AttributeManager"](this.context.gl, {
      id: this.props.id,
      stats: this.context.stats
    });
  }

  _getChangeFlags(opts) {
    const changeFlags = {};
    const {dimensions} = this.state;
    changeFlags.dataChanged =
      this.isAttributeChanged() || // if any attribute is changed
      this.isAggregationDirty(opts, {
        compareAll: true,
        dimension: dimensions.data
      });
    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;

    const {zoom} = this.state;
    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
      changeFlags.viewportZoomChanged = true;
    }

    return changeFlags;
  }

  _createTextures() {
    const {gl} = this.context;
    const {textureSize, format, type} = this.state;

    this.setState({
      weightsTexture: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](gl, {
        width: textureSize,
        height: textureSize,
        format,
        type,
        ...TEXTURE_OPTIONS
      }),
      maxWeightsTexture: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](gl, {format, type, ...TEXTURE_OPTIONS}) // 1 X 1 texture,
    });
  }

  _setupAttributes() {
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {size: 3, accessor: 'getPosition'},
      weights: {size: 1, accessor: 'getWeight'}
    });
    this.setState({positionAttributeName: 'positions'});
  }

  _setupTextureParams() {
    const {gl} = this.context;
    const textureSize = Math.min(SIZE_2K, Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["getParameters"])(gl, gl.MAX_TEXTURE_SIZE));
    const floatTargetSupport = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].COLOR_ATTACHMENT_RGBA32F);
    const {format, type} = Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["getTextureParams"])({gl, floatTargetSupport});
    const weightsScale = floatTargetSupport ? 1 : 1 / 255;
    this.setState({textureSize, format, type, weightsScale});
    if (!floatTargetSupport) {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["log"].warn(
        `HeatmapLayer: ${
          this.id
        } rendering to float texture not supported, fallingback to low precession format`
      )();
    }
  }

  _createWeightsTransform(shaderOptions = {}) {
    const {gl} = this.context;
    let {weightsTransform} = this.state;
    const {weightsTexture} = this.state;
    if (weightsTransform) {
      weightsTransform.delete();
    }
    const shaders = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["_mergeShaders"])(
      {
        vs: _weights_vs_glsl__WEBPACK_IMPORTED_MODULE_6__["default"],
        _fs: _weights_fs_glsl__WEBPACK_IMPORTED_MODULE_7__["default"],
        modules: [_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["project32"]]
      },
      shaderOptions
    );

    weightsTransform = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Transform"](gl, {
      id: `${this.id}-weights-transform`,
      elementCount: 1,
      _targetTexture: weightsTexture,
      _targetTextureVarying: 'weightsTexture',
      ...shaders
    });
    this.setState({weightsTransform});
  }

  _setupResources() {
    const {gl} = this.context;
    this._createTextures();
    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;
    this._createWeightsTransform();
    const maxWeightTransform = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Transform"](gl, {
      id: `${this.id}-max-weights-transform`,
      _sourceTextures: {
        inTexture: weightsTexture
      },
      _targetTexture: maxWeightsTexture,
      _targetTextureVarying: 'outTexture',
      vs: _max_vs_glsl__WEBPACK_IMPORTED_MODULE_8__["default"],
      elementCount: textureSize * textureSize
    });

    this.setState({
      weightsTexture,
      maxWeightsTexture,
      maxWeightTransform,
      zoom: null,
      triPositionBuffer: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
        byteLength: 48,
        accessor: {size: 3}
      }),
      triTexCoordBuffer: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
        byteLength: 48,
        accessor: {size: 2}
      })
    });
  }

  // overwrite super class method to update transform model
  updateShaders(shaderOptions) {
    // sahder params (modules, injects) changed, update model object
    this._createWeightsTransform(shaderOptions);
  }

  _updateMaxWeightValue() {
    const {maxWeightTransform} = this.state;
    maxWeightTransform.run({
      parameters: {
        blend: true,
        depthTest: false,
        blendFunc: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE],
        blendEquation: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX
      }
    });
  }

  // Computes world bounds area that needs to be processed for generate heatmap
  _updateBounds(forceUpdate = false) {
    const {viewport} = this.context;

    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)
    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)
    const viewportCorners = [
      viewport.unproject([0, 0]),
      viewport.unproject([viewport.width, 0]),
      viewport.unproject([viewport.width, viewport.height]),
      viewport.unproject([0, viewport.height])
    ];

    // #1: get world bounds for current viewport extends
    const visibleWorldBounds = Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["getBounds"])(viewportCorners); // TODO: Change to visible bounds

    const newState = {visibleWorldBounds, viewportCorners};
    let boundsChanged = false;

    if (
      forceUpdate ||
      !this.state.worldBounds ||
      !Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["boundsContain"])(this.state.worldBounds, visibleWorldBounds)
    ) {
      // #2 : convert world bounds to common (Flat) bounds
      // #3 : extend common bounds to match aspect ratio with viewport
      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);

      // #4 :convert aligned common bounds to world bounds
      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);

      // Clip webmercator projection limits
      if (this.props.coordinateSystem === _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["COORDINATE_SYSTEM"].LNGLAT) {
        worldBounds[1] = Math.max(worldBounds[1], -85.051129);
        worldBounds[3] = Math.min(worldBounds[3], 85.051129);
        worldBounds[0] = Math.max(worldBounds[0], -360);
        worldBounds[2] = Math.min(worldBounds[2], 360);
      }

      // #5: now convert world bounds to common using Layer's coordiante system and origin
      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);

      newState.worldBounds = worldBounds;
      newState.normalizedCommonBounds = normalizedCommonBounds;

      boundsChanged = true;
    }
    this.setState(newState);
    return boundsChanged;
  }

  _updateTextureRenderingBounds() {
    // Just render visible portion of the texture
    const {
      triPositionBuffer,
      triTexCoordBuffer,
      normalizedCommonBounds,
      viewportCorners
    } = this.state;

    const {viewport} = this.context;

    triPositionBuffer.subData(Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["packVertices"])(viewportCorners, 3));

    const textureBounds = viewportCorners.map(p =>
      Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["getTextureCoordinates"])(viewport.projectPosition(p), normalizedCommonBounds)
    );
    triTexCoordBuffer.subData(Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["packVertices"])(textureBounds, 2));
  }

  _updateColorTexture(opts) {
    const {colorRange} = opts.props;
    let {colorTexture} = this.state;
    const colors = Object(_utils_color_utils__WEBPACK_IMPORTED_MODULE_5__["colorRangeToFlatArray"])(colorRange, true);

    if (colorTexture) {
      colorTexture.setImageData({
        data: colors,
        width: colorRange.length
      });
    } else {
      colorTexture = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.context.gl, {
        data: colors,
        width: colorRange.length,
        height: 1,
        format: Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.context.gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT,
        ...TEXTURE_OPTIONS
      });
    }
    this.setState({colorTexture});
  }

  _updateWeightmap() {
    const {radiusPixels} = this.props;
    const {weightsTransform, worldBounds, textureSize, weightsTexture, weightsScale} = this.state;

    // #5: convert world bounds to common using Layer's coordiante system and origin
    const commonBounds = this._worldToCommonBounds(worldBounds, {
      useLayerCoordinateSystem: true
    });

    const uniforms = {
      radiusPixels,
      commonBounds,
      textureWidth: textureSize,
      weightsScale
    };
    // Attribute manager sets data array count as instaceCount on model
    // we need to set that as elementCount on 'weightsTransform'
    weightsTransform.update({
      elementCount: this.getNumInstances()
    });
    weightsTransform.run({
      uniforms,
      parameters: {
        blend: true,
        depthTest: false,
        blendFunc: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE],
        blendEquation: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD
      },
      clearRenderTarget: true,
      attributes: this.getAttributes(),
      moduleSettings: this.getModuleSettings()
    });
    this._updateMaxWeightValue();

    // reset filtering parameters (TODO: remove once luma issue#1193 is fixed)
    weightsTexture.setParameters({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR
    });

    this.setState({lastUpdate: Date.now()});
  }

  _debouncedUpdateWeightmap(fromTimer = false) {
    let {updateTimer} = this.state;
    const timeSinceLastUpdate = Date.now() - this.state.lastUpdate;

    if (fromTimer) {
      updateTimer = null;
    }

    if (timeSinceLastUpdate >= ZOOM_DEBOUNCE) {
      // update
      this._updateBounds(true);
      this._updateWeightmap();
      this._updateTextureRenderingBounds();
    } else if (!updateTimer) {
      updateTimer = setTimeout(
        this._debouncedUpdateWeightmap.bind(this, true),
        ZOOM_DEBOUNCE - timeSinceLastUpdate
      );
    }

    this.setState({updateTimer});
  }

  // input: worldBounds: [minLong, minLat, maxLong, maxLat]
  // input: opts.useLayerCoordinateSystem : layers coordiante system is used
  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture
  _worldToCommonBounds(worldBounds, opts = {}) {
    const {useLayerCoordinateSystem = false} = opts;
    const [minLong, minLat, maxLong, maxLat] = worldBounds;
    const {viewport} = this.context;
    const {textureSize} = this.state;

    const size = (textureSize * RESOLUTION) / viewport.scale;

    let bottomLeftCommon;
    let topRightCommon;

    // Y-axis is flipped between World and Common bounds
    if (useLayerCoordinateSystem) {
      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
    } else {
      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
    }
    // Ignore z component
    let commonBounds = bottomLeftCommon.slice(0, 2).concat(topRightCommon.slice(0, 2));
    commonBounds = Object(_heatmap_layer_utils__WEBPACK_IMPORTED_MODULE_1__["scaleToAspectRatio"])(commonBounds, size, size);
    return commonBounds;
  }

  // input commonBounds: [xMin, yMin, xMax, yMax]
  // output worldBounds: [minLong, minLat, maxLong, maxLat]
  _commonToWorldBounds(commonBounds) {
    const [xMin, yMin, xMax, yMax] = commonBounds;
    const {viewport} = this.context;
    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);

    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
  }
}

HeatmapLayer.layerName = 'HeatmapLayer';
HeatmapLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/heatmap-layer/max-vs.glsl.js":
/*!******************************************!*\
  !*** ./src/heatmap-layer/max-vs.glsl.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
attribute vec4 inTexture;
varying vec4 outTexture;

void main()
{
outTexture = inTexture;
gl_Position = vec4(0, 0, 0, 1.);
// Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
gl_PointSize = 1.0;
}
`);


/***/ }),

/***/ "./src/heatmap-layer/triangle-layer-fragment.glsl.js":
/*!***********************************************************!*\
  !*** ./src/heatmap-layer/triangle-layer-fragment.glsl.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME triangle-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D texture;
varying vec2 vTexCoords;
uniform sampler2D colorTexture;

varying float vIntensityMin;
varying float vIntensityMax;

vec4 getLinearColor(float value) {
  float factor = clamp(value * vIntensityMax, 0., 1.);
  vec4 color = texture2D(colorTexture, vec2(factor, 0.5));
  color.a *= min(value * vIntensityMin, 1.0);
  return color;
}

void main(void) {
  float weight = texture2D(texture, vTexCoords).r;
  // discard pixels with 0 weight.
  if (weight <= 0.) {
     discard;
  }

  vec4 linearColor = getLinearColor(weight);
  linearColor.a *= opacity;
  gl_FragColor =linearColor;
}
`);


/***/ }),

/***/ "./src/heatmap-layer/triangle-layer-vertex.glsl.js":
/*!*********************************************************!*\
  !*** ./src/heatmap-layer/triangle-layer-vertex.glsl.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Inspired by screen-grid-layer vertex shader in deck.gl

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME heatp-map-layer-vertex-shader

uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;

attribute vec3 positions;
attribute vec2 texCoords;

varying vec2 vTexCoords;
varying float vIntensityMin;
varying float vIntensityMax;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
  vTexCoords = texCoords;
  float maxValue = texture2D(maxTexture, vec2(0.5)).r;
  float minValue = maxValue * threshold;
  if (colorDomain[1] > 0.) {
    // if user specified custom domain use it.
    maxValue = colorDomain[1];
    minValue = colorDomain[0];
  }
  vIntensityMax = intensity / maxValue;
  vIntensityMin = intensity / minValue;
}
`);


/***/ }),

/***/ "./src/heatmap-layer/triangle-layer.js":
/*!*********************************************!*\
  !*** ./src/heatmap-layer/triangle-layer.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TriangleLayer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _triangle_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./triangle-layer-vertex.glsl */ "./src/heatmap-layer/triangle-layer-vertex.glsl.js");
/* harmony import */ var _triangle_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./triangle-layer-fragment.glsl */ "./src/heatmap-layer/triangle-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.







const defaultProps = {
  count: 0, // number of triangles to be rendered
  texture: null
};

class TriangleLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["Layer"] {
  getShaders() {
    return {vs: _triangle_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _triangle_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], modules: [_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["project32"]]};
  }

  initializeState() {
    const {gl} = this.context;
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {size: 3, noAlloc: true},
      texCoords: {size: 2, noAlloc: true}
    });
    this.setState({
      model: this._getModel(gl)
    });
  }

  _getModel(gl) {
    const {vertexCount} = this.props;

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLE_FAN,
          vertexCount
        })
      })
    );
  }

  draw({uniforms}) {
    const {model} = this.state;

    const {texture, maxTexture, colorTexture, intensity, threshold, colorDomain} = this.props;
    model
      .setUniforms({
        ...uniforms,
        texture,
        maxTexture,
        colorTexture,
        intensity,
        threshold,
        colorDomain
      })
      .draw();
  }
}

TriangleLayer.layerName = 'TriangleLayer';
TriangleLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/heatmap-layer/weights-fs.glsl.js":
/*!**********************************************!*\
  !*** ./src/heatmap-layer/weights-fs.glsl.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
varying vec4 weightsTexture;
// Epanechnikov function, keeping for reference
// float epanechnikovKDE(float u) {
//   return 0.75 * (1.0 - u * u);
// }
float gaussianKDE(float u){
  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
  float dist = length(gl_PointCoord - vec2(0.5, 0.5));
  if (dist > 0.5) {
    discard;
  }
  gl_FragColor.rgb = weightsTexture.rgb * gaussianKDE(2. * dist);
  gl_FragColor.a = 1.0;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`);


/***/ }),

/***/ "./src/heatmap-layer/weights-vs.glsl.js":
/*!**********************************************!*\
  !*** ./src/heatmap-layer/weights-vs.glsl.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
attribute vec3 positions;
attribute float weights;
varying vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;
void main()
{
  weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);

  float radiusTexels  = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
  gl_PointSize = radiusTexels * 2.;

  vec3 commonPosition = project_position(positions);

  // map xy from commonBounds to [-1, 1]
  gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
  gl_Position.xy = (gl_Position.xy * 2.) - (1.);
}
`);


/***/ }),

/***/ "./src/hexagon-layer/hexagon-aggregator.js":
/*!*************************************************!*\
  !*** ./src/hexagon-layer/hexagon-aggregator.js ***!
  \*************************************************/
/*! exports provided: pointToHexbin, getRadiusInCommon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointToHexbin", function() { return pointToHexbin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRadiusInCommon", function() { return getRadiusInCommon; });
/* harmony import */ var d3_hexbin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-hexbin */ "../../node_modules/d3-hexbin/index.js");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




/**
 * Use d3-hexbin to performs hexagonal binning from geo points to hexagons
 * @param {Iterable} data - array of points
 * @param {Number} radius - hexagon radius in meter
 * @param {function} getPosition - get points lon lat
 * @param {Object} viewport - current viewport object

 * @return {Object} - hexagons and countRange
 */
function pointToHexbin(props, aggregationParams) {
  const {data, radius} = props;
  const {viewport, attributes} = aggregationParams;
  // get hexagon radius in mercator world unit
  const radiusCommon = getRadiusInCommon(radius, viewport);

  // add world space coordinates to points
  const screenPoints = [];
  const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["createIterable"])(data);
  const positions = attributes.positions.value;
  const {size} = attributes.positions.getAccessor();
  for (const object of iterable) {
    objectInfo.index++;
    const posIndex = objectInfo.index * size;
    const position = [positions[posIndex], positions[posIndex + 1]];
    const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);
    if (arrayIsFinite) {
      screenPoints.push(
        Object.assign(
          {
            screenCoord: viewport.projectFlat(position)
          },
          object
        )
      );
    } else {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["log"].warn('HexagonLayer: invalid position')();
    }
  }

  const newHexbin = Object(d3_hexbin__WEBPACK_IMPORTED_MODULE_0__["hexbin"])()
    .radius(radiusCommon)
    .x(d => d.screenCoord[0])
    .y(d => d.screenCoord[1]);

  const hexagonBins = newHexbin(screenPoints);

  return {
    hexagons: hexagonBins.map((hex, index) => ({
      position: viewport.unprojectFlat([hex.x, hex.y]),
      points: hex,
      index
    }))
  };
}

/**
 * Get radius in mercator world space coordinates from meter
 * @param {Number} radius - in meter
 * @param {Object} viewport - current viewport object

 * @return {Number} radius in mercator world spcae coordinates
 */
function getRadiusInCommon(radius, viewport) {
  const {unitsPerMeter} = viewport.getDistanceScales();

  // x, y distance should be the same
  return radius * unitsPerMeter[0];
}


/***/ }),

/***/ "./src/hexagon-layer/hexagon-layer.js":
/*!********************************************!*\
  !*** ./src/hexagon-layer/hexagon-layer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HexagonLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _hexagon_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hexagon-aggregator */ "./src/hexagon-layer/hexagon-aggregator.js");
/* harmony import */ var _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cpu-aggregator */ "./src/utils/cpu-aggregator.js");
/* harmony import */ var _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../aggregation-layer */ "./src/aggregation-layer.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.










function nop() {}

const defaultProps = {
  // color
  colorDomain: null,
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_1__["defaultColorRange"],
  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`
  getColorWeight: {type: 'accessor', value: x => 1},
  colorAggregation: 'SUM',
  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},
  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},
  colorScaleType: 'quantize',
  onSetColorDomain: nop,

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`
  getElevationWeight: {type: 'accessor', value: x => 1},
  elevationAggregation: 'SUM',
  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},
  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},
  elevationScale: {type: 'number', min: 0, value: 1},
  elevationScaleType: 'linear',
  onSetElevationDomain: nop,

  radius: {type: 'number', value: 1000, min: 1},
  coverage: {type: 'number', min: 0, max: 1, value: 1},
  extruded: false,
  hexagonAggregator: _hexagon_aggregator__WEBPACK_IMPORTED_MODULE_2__["pointToHexbin"],
  getPosition: {type: 'accessor', value: x => x.position},
  // Optional material for 'lighting' shader module
  material: true,

  // data filter
  _filterData: {type: 'function', value: null, optional: true}
};

class HexagonLayer extends _aggregation_layer__WEBPACK_IMPORTED_MODULE_4__["default"] {
  initializeState() {
    const cpuAggregator = new _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_3__["default"]({
      getAggregator: props => props.hexagonAggregator,
      getCellSize: props => props.radius
    });

    this.state = {
      cpuAggregator,
      aggregatorState: cpuAggregator.state
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {size: 3, accessor: 'getPosition'}
    });
    // color and elevation attributes can't be added as attributes
    // they are calcualted using 'getValue' accessor that takes an array of pints.
  }

  updateState(opts) {
    super.updateState(opts);
    const {cpuAggregator} = this.state;
    const oldLayerData = cpuAggregator.state.layerData;
    this.setState({
      // make a copy of the internal state of cpuAggregator for testing
      aggregatorState: cpuAggregator.updateState(opts, {
        viewport: this.context.viewport,
        attributes: this.getAttributes()
      })
    });

    if (oldLayerData !== cpuAggregator.state.layerData) {
      const {hexagonVertices} = cpuAggregator.state.layerData;
      this.updateRadiusAngle(hexagonVertices);
    }
  }

  updateRadiusAngle(vertices) {
    let {radius} = this.props;
    let angle = 90;

    if (Array.isArray(vertices)) {
      if (vertices.length < 6) {
        _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].error('HexagonCellLayer: hexagonVertices needs to be an array of 6 points')();
      }

      // calculate angle and vertices from hexagonVertices if provided
      const vertex0 = vertices[0];
      const vertex3 = vertices[3];

      // transform to space coordinates
      const {viewport} = this.context;
      const {unitsPerMeter} = viewport.getDistanceScales();
      const spaceCoord0 = this.projectFlat(vertex0);
      const spaceCoord3 = this.projectFlat(vertex3);

      // distance between two close centroids
      const dx = spaceCoord0[0] - spaceCoord3[0];
      const dy = spaceCoord0[1] - spaceCoord3[1];
      const dxy = Math.sqrt(dx * dx + dy * dy);

      // Calculate angle that the perpendicular hexagon vertex axis is tilted
      angle = ((Math.acos(dx / dxy) * -Math.sign(dy)) / Math.PI) * 180 + 90;
      radius = dxy / 2 / unitsPerMeter[0];
    }

    this.setState({angle, radius});
  }

  getPickingInfo({info}) {
    return this.state.cpuAggregator.getPickingInfo({info});
  }

  // create a method for testing
  _onGetSublayerColor(cell) {
    return this.state.cpuAggregator.getAccessor('fillColor')(cell);
  }

  // create a method for testing
  _onGetSublayerElevation(cell) {
    return this.state.cpuAggregator.getAccessor('elevation')(cell);
  }

  _getSublayerUpdateTriggers() {
    return this.state.cpuAggregator.getUpdateTriggers(this.props);
  }

  renderLayers() {
    const {elevationScale, extruded, coverage, material, transitions} = this.props;
    const {angle, radius, cpuAggregator} = this.state;

    const SubLayerClass = this.getSubLayerClass('hexagon-cell', _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["ColumnLayer"]);
    const updateTriggers = this._getSublayerUpdateTriggers();

    return new SubLayerClass(
      {
        radius,
        diskResolution: 6,
        elevationScale,
        angle,
        extruded,
        coverage,
        material,

        getFillColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        transitions: transitions && {
          getFillColor: transitions.getColorValue || transitions.getColorWeight,
          getElevation: transitions.getElevationValue || transitions.getElevationWeight
        }
      },
      this.getSubLayerProps({
        id: 'hexagon-cell',
        updateTriggers
      }),
      {
        data: cpuAggregator.state.layerData.data
      }
    );
  }
}

HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ScreenGridLayer, CPUGridLayer, HexagonLayer, ContourLayer, GridLayer, GPUGridLayer, AGGREGATION_OPERATION, HeatmapLayer, _GPUGridAggregator, _CPUAggregator, _BinSorter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _screen_grid_layer_screen_grid_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./screen-grid-layer/screen-grid-layer */ "./src/screen-grid-layer/screen-grid-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScreenGridLayer", function() { return _screen_grid_layer_screen_grid_layer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _cpu_grid_layer_cpu_grid_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cpu-grid-layer/cpu-grid-layer */ "./src/cpu-grid-layer/cpu-grid-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CPUGridLayer", function() { return _cpu_grid_layer_cpu_grid_layer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _hexagon_layer_hexagon_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hexagon-layer/hexagon-layer */ "./src/hexagon-layer/hexagon-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HexagonLayer", function() { return _hexagon_layer_hexagon_layer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _contour_layer_contour_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contour-layer/contour-layer */ "./src/contour-layer/contour-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContourLayer", function() { return _contour_layer_contour_layer__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _grid_layer_grid_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grid-layer/grid-layer */ "./src/grid-layer/grid-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridLayer", function() { return _grid_layer_grid_layer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _gpu_grid_layer_gpu_grid_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gpu-grid-layer/gpu-grid-layer */ "./src/gpu-grid-layer/gpu-grid-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GPUGridLayer", function() { return _gpu_grid_layer_gpu_grid_layer__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AGGREGATION_OPERATION", function() { return _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_6__["AGGREGATION_OPERATION"]; });

/* harmony import */ var _heatmap_layer_heatmap_layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./heatmap-layer/heatmap-layer */ "./src/heatmap-layer/heatmap-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeatmapLayer", function() { return _heatmap_layer_heatmap_layer__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_GPUGridAggregator", function() { return _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/cpu-aggregator */ "./src/utils/cpu-aggregator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_CPUAggregator", function() { return _utils_cpu_aggregator__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _utils_bin_sorter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/bin-sorter */ "./src/utils/bin-sorter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_BinSorter", function() { return _utils_bin_sorter__WEBPACK_IMPORTED_MODULE_10__["default"]; });

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/* eslint-disable max-len */









// experimental export







/***/ }),

/***/ "./src/screen-grid-layer/screen-grid-cell-layer.js":
/*!*********************************************************!*\
  !*** ./src/screen-grid-layer/screen-grid-cell-layer.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScreenGridCellLayer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_color_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/color-utils */ "./src/utils/color-utils.js");
/* harmony import */ var _screen_grid_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./screen-grid-layer-vertex.glsl */ "./src/screen-grid-layer/screen-grid-layer-vertex.glsl.js");
/* harmony import */ var _screen_grid_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./screen-grid-layer-fragment.glsl */ "./src/screen-grid-layer/screen-grid-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.








const DEFAULT_MINCOLOR = [0, 0, 0, 0];
const DEFAULT_MAXCOLOR = [0, 255, 0, 255];
const COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];

const defaultProps = {
  cellSizePixels: {value: 100, min: 1},
  cellMarginPixels: {value: 2, min: 0, max: 5},

  colorDomain: null,
  colorRange: _utils_color_utils__WEBPACK_IMPORTED_MODULE_2__["defaultColorRange"]
};

class ScreenGridCellLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["Layer"] {
  static isSupported(gl) {
    return Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].TEXTURE_FLOAT]);
  }

  getShaders() {
    return {vs: _screen_grid_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], fs: _screen_grid_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], modules: [_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["picking"]]};
  }

  initializeState() {
    const {gl} = this.context;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {size: 3, update: this.calculateInstancePositions},
      instanceCounts: {size: 4, noAlloc: true}
    });
    this.setState({
      model: this._getModel(gl)
    });
  }

  shouldUpdateState({changeFlags}) {
    // 'instanceCounts' buffer contetns change on viewport change.
    return changeFlags.somethingChanged;
  }

  updateState({oldProps, props, changeFlags}) {
    super.updateState({oldProps, props, changeFlags});

    const attributeManager = this.getAttributeManager();
    if (props.numInstances !== oldProps.numInstances) {
      attributeManager.invalidateAll();
    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {
      attributeManager.invalidate('instancePositions');
    }

    this._updateUniforms(oldProps, props, changeFlags);
  }

  draw({uniforms}) {
    const {parameters, maxTexture} = this.props;
    const minColor = this.props.minColor || DEFAULT_MINCOLOR;
    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;

    // If colorDomain not specified we use default domain [1, maxCount]
    // maxCount value will be sampled form maxTexture in vertex shader.
    const colorDomain = this.props.colorDomain || [1, 0];
    const {model} = this.state;
    const layerUniforms = {
      minColor,
      maxColor,
      maxTexture,
      colorDomain
    };

    uniforms = Object.assign(layerUniforms, uniforms);
    model.draw({
      uniforms,
      parameters: Object.assign(
        {
          depthTest: false,
          depthMask: false
        },
        parameters
      )
    });
  }

  calculateInstancePositions(attribute, {numInstances}) {
    const {width, height} = this.context.viewport;
    const {cellSizePixels} = this.props;
    const numCol = Math.ceil(width / cellSizePixels);

    const {value, size} = attribute;

    for (let i = 0; i < numInstances; i++) {
      const x = i % numCol;
      const y = Math.floor(i / numCol);
      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;
      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;
      value[i * size + 2] = 0;
    }
  }

  // Private Methods

  _getModel(gl) {
    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLE_FAN,
          attributes: {
            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])
          }
        }),
        isInstanced: true
      })
    );
  }

  _shouldUseMinMax() {
    const {minColor, maxColor, colorDomain, colorRange} = this.props;
    if (minColor || maxColor) {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["log"].deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();
      return true;
    }
    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.
    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.
    if (colorDomain || colorRange) {
      return false;
    }
    // None specified, use default minColor and maxColor
    return true;
  }

  _updateUniforms(oldProps, props, changeFlags) {
    const {model} = this.state;
    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {
      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});
    }

    if (oldProps.colorRange !== props.colorRange) {
      model.setUniforms({colorRange: Object(_utils_color_utils__WEBPACK_IMPORTED_MODULE_2__["colorRangeToFlatArray"])(props.colorRange)});
    }

    if (
      oldProps.cellMarginPixels !== props.cellMarginPixels ||
      oldProps.cellSizePixels !== props.cellSizePixels ||
      changeFlags.viewportChanged
    ) {
      const {width, height} = this.context.viewport;
      const {cellSizePixels, cellMarginPixels} = this.props;
      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;

      const cellScale = new Float32Array([
        ((cellSizePixels - margin) / width) * 2,
        (-(cellSizePixels - margin) / height) * 2,
        1
      ]);
      model.setUniforms({cellScale});
    }
  }
}

ScreenGridCellLayer.layerName = 'ScreenGridCellLayer';
ScreenGridCellLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/screen-grid-layer/screen-grid-layer-fragment.glsl.js":
/*!******************************************************************!*\
  !*** ./src/screen-grid-layer/screen-grid-layer-fragment.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* fragment shader for the grid-layer */
/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME screen-grid-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying float vSampleCount;

void main(void) {
  if (vSampleCount <= 0.0) {
    discard;
  }
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`);


/***/ }),

/***/ "./src/screen-grid-layer/screen-grid-layer-vertex.glsl.js":
/*!****************************************************************!*\
  !*** ./src/screen-grid-layer/screen-grid-layer-vertex.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6

attribute vec3 positions;
attribute vec3 instancePositions;
attribute vec4 instanceCounts;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;

varying vec4 vColor;
varying float vSampleCount;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= domain.x && value <= domain.y) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  outColor = outColor / 255.;
  return outColor;
}

void main(void) {
  vSampleCount = instanceCounts.a;

  float weight = instanceCounts.r;
  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;

  float step = weight / maxWeight;
  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;

  vec2 domain = colorDomain;
  float domainMaxValid = float(colorDomain.y != 0.);
  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
  vec4 rangeColor = quantizeScale(domain, colorRange, weight);

  float rangeMinMax = float(shouldUseMinMax);
  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
  vColor = vec4(color.rgb, color.a * opacity);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`);


/***/ }),

/***/ "./src/screen-grid-layer/screen-grid-layer.js":
/*!****************************************************!*\
  !*** ./src/screen-grid-layer/screen-grid-layer.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScreenGridLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/gpu-grid-aggregation/gpu-grid-aggregator */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js");
/* harmony import */ var _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
/* harmony import */ var _screen_grid_cell_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./screen-grid-cell-layer */ "./src/screen-grid-layer/screen-grid-cell-layer.js");
/* harmony import */ var _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../grid-aggregation-layer */ "./src/grid-aggregation-layer.js");
/* harmony import */ var _utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/resource-utils.js */ "./src/utils/resource-utils.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.









const defaultProps = Object.assign({}, _screen_grid_cell_layer__WEBPACK_IMPORTED_MODULE_4__["default"].defaultProps, {
  getPosition: {type: 'accessor', value: d => d.position},
  getWeight: {type: 'accessor', value: d => 1},

  gpuAggregation: true,
  aggregation: 'SUM'
});

const POSITION_ATTRIBUTE_NAME = 'positions';
const DIMENSIONS = {
  data: {
    props: ['cellSizePixels']
  },
  weights: {
    props: ['aggregation'],
    accessors: ['getWeight']
  }
};

class ScreenGridLayer extends _grid_aggregation_layer__WEBPACK_IMPORTED_MODULE_5__["default"] {
  initializeState() {
    const {gl} = this.context;
    if (!_screen_grid_cell_layer__WEBPACK_IMPORTED_MODULE_4__["default"].isSupported(gl)) {
      // max aggregated value is sampled from a float texture
      this.setState({supported: false});
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();
      return;
    }
    super.initializeState({
      dimensions: DIMENSIONS,
      getCellSize: props => props.cellSizePixels
    });
    const weights = {
      count: {
        size: 1,
        operation: _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"].SUM,
        needMax: true,
        maxTexture: Object(_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_6__["getFloatTexture"])(gl, {id: `${this.id}-max-texture`})
      }
    };
    this.setState({
      supported: true,
      projectPoints: true, // aggregation in screen space
      weights,
      subLayerData: {attributes: {}},
      maxTexture: weights.count.maxTexture,
      positionAttributeName: 'positions',
      posOffset: [0, 0],
      translation: [1, -1]
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME]: {
        size: 3,
        accessor: 'getPosition',
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.DOUBLE,
        fp64: this.use64bitPositions()
      },
      // this attribute is used in gpu aggregation path only
      count: {size: 3, accessor: 'getWeight'}
    });
  }

  shouldUpdateState({changeFlags}) {
    return this.state.supported && changeFlags.somethingChanged;
  }

  updateState(opts) {
    super.updateState(opts);
  }

  renderLayers() {
    if (!this.state.supported) {
      return [];
    }
    const {maxTexture, numRow, numCol, weights} = this.state;
    const {updateTriggers} = this.props;
    const {aggregationBuffer} = weights.count;
    const CellLayerClass = this.getSubLayerClass('cells', _screen_grid_cell_layer__WEBPACK_IMPORTED_MODULE_4__["default"]);

    return new CellLayerClass(
      this.props,
      this.getSubLayerProps({
        id: 'cell-layer',
        updateTriggers
      }),
      {
        data: {attributes: {instanceCounts: aggregationBuffer}},
        maxTexture,
        numInstances: numRow * numCol
      }
    );
  }

  finalizeState() {
    super.finalizeState();

    const {aggregationBuffer, maxBuffer, gpuGridAggregator, maxTexture} = this.state;
    gpuGridAggregator.delete();
    if (aggregationBuffer) {
      aggregationBuffer.delete();
    }
    if (maxBuffer) {
      maxBuffer.delete();
    }
    if (maxTexture) {
      maxTexture.delete();
    }
  }

  getPickingInfo({info, mode}) {
    const {index} = info;
    if (index >= 0) {
      const {gpuGridAggregator} = this.state;
      // Get count aggregation results
      const aggregationResults = gpuGridAggregator.getData('count');

      // Each instance (one cell) is aggregated into single pixel,
      // Get current instance's aggregation details.
      info.object = _utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"].getAggregationData(
        Object.assign({pixelIndex: index}, aggregationResults)
      );
    }

    return info;
  }

  // Aggregation Overrides

  updateResults({aggregationData, maxData}) {
    const {count} = this.state.weights;
    count.aggregationData = aggregationData;
    count.aggregationBuffer.setData({data: aggregationData});
    count.maxData = maxData;
    count.maxTexture.setImageData({data: maxData});
  }

  /* eslint-disable complexity, max-statements */
  updateAggregationState(opts) {
    const cellSize = opts.props.cellSizePixels;
    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;
    const {viewportChanged} = opts.changeFlags;
    let gpuAggregation = opts.props.gpuAggregation;
    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {
      if (gpuAggregation && !_utils_gpu_grid_aggregation_gpu_grid_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"].isSupported(this.context.gl)) {
        _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn('GPU Grid Aggregation not supported, falling back to CPU')();
        gpuAggregation = false;
      }
    }
    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
    this.setState({
      gpuAggregation
    });

    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);

    const {dimensions} = this.state;
    const {data, weights} = dimensions;
    const aggregationDataDirty =
      positionsChanged ||
      gpuAggregationChanged ||
      viewportChanged ||
      this.isAggregationDirty(opts, {
        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation
        dimension: data
      });
    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});

    this.setState({
      aggregationDataDirty,
      aggregationWeightsDirty
    });

    const {viewport} = this.context;

    if (viewportChanged || cellSizeChanged) {
      const {width, height} = viewport;
      const numCol = Math.ceil(width / cellSize);
      const numRow = Math.ceil(height / cellSize);
      this.allocateResources(numRow, numCol);
      this.setState({
        // transformation from clipspace to screen(pixel) space
        scaling: [width / 2, -height / 2, 1],

        gridOffset: {xOffset: cellSize, yOffset: cellSize},
        width,
        height,
        numCol,
        numRow
      });
    }

    if (aggregationWeightsDirty) {
      this._updateAccessors(opts);
    }
    if (aggregationDataDirty || aggregationWeightsDirty) {
      this._resetResults();
    }
  }
  /* eslint-enable complexity, max-statements */

  // Private

  _updateAccessors(opts) {
    const {getWeight, aggregation} = opts.props;
    const {count} = this.state.weights;
    if (count) {
      count.getWeight = getWeight;
      count.operation = _utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"][aggregation];
    }
    this.setState({getValue: Object(_utils_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["getValueFunc"])(aggregation, getWeight)});
  }

  _resetResults() {
    const {count} = this.state.weights;
    if (count) {
      count.aggregationData = null;
    }
  }
}

ScreenGridLayer.layerName = 'ScreenGridLayer';
ScreenGridLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/utils/aggregation-operation-utils.js":
/*!**************************************************!*\
  !*** ./src/utils/aggregation-operation-utils.js ***!
  \**************************************************/
/*! exports provided: AGGREGATION_OPERATION, getMean, getSum, getMax, getMin, getValueFunc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AGGREGATION_OPERATION", function() { return AGGREGATION_OPERATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMean", function() { return getMean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSum", function() { return getSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMax", function() { return getMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMin", function() { return getMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueFunc", function() { return getValueFunc; });
// Copyright (c) 2015 - 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

const AGGREGATION_OPERATION = {
  SUM: 1,
  MEAN: 2,
  MIN: 3,
  MAX: 4
};

function sumReducer(accu, cur) {
  return accu + cur;
}

function maxReducer(accu, cur) {
  return cur > accu ? cur : accu;
}

function minReducer(accu, cur) {
  return cur < accu ? cur : accu;
}

function getMean(pts, accessor) {
  const filtered = pts.map(accessor).filter(Number.isFinite);

  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;
}

function getSum(pts, accessor) {
  const filtered = pts.map(accessor).filter(Number.isFinite);

  return filtered.length ? filtered.reduce(sumReducer, 0) : null;
}

function getMax(pts, accessor) {
  const filtered = pts.map(accessor).filter(Number.isFinite);

  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;
}

function getMin(pts, accessor) {
  const filtered = pts.map(accessor).filter(Number.isFinite);

  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;
}

// Function to convert from aggregation/accessor props (like colorAggregation and getColorWeight) to getValue prop (like getColorValue)
function getValueFunc(aggregation, accessor) {
  const op = AGGREGATION_OPERATION[aggregation.toUpperCase()] || AGGREGATION_OPERATION.SUM;
  switch (op) {
    case AGGREGATION_OPERATION.MIN:
      return pts => getMin(pts, accessor);
    case AGGREGATION_OPERATION.SUM:
      return pts => getSum(pts, accessor);
    case AGGREGATION_OPERATION.MEAN:
      return pts => getMean(pts, accessor);
    case AGGREGATION_OPERATION.MAX:
      return pts => getMax(pts, accessor);
    default:
      return null;
  }
}


/***/ }),

/***/ "./src/utils/bin-sorter.js":
/*!*********************************!*\
  !*** ./src/utils/bin-sorter.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BinSorter; });
/* harmony import */ var _scale_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scale-utils */ "./src/utils/scale-utils.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// getValue takes an array of points returns a value to sort the bins on.
// by default it returns the number of points
// this is where to pass in a function to color the bins by
// avg/mean/max of specific value of the point
const defaultGetValue = points => points.length;



const MAX_32_BIT_FLOAT = 3.402823466e38;

// access array of points in each bin
const defaultGetPoints = bin => bin.points;
// access index of each bin
const defaultGetIndex = bin => bin.index;

const defaultProps = {
  getValue: defaultGetValue,
  getPoints: defaultGetPoints,
  getIndex: defaultGetIndex,
  filterData: null
};

class BinSorter {
  constructor(bins = [], props = defaultProps) {
    this.aggregatedBins = this.getAggregatedBins(bins, props);
    this._updateMinMaxValues();
    this.binMap = this.getBinMap();
  }

  /**
   * Get an array of object with aggregated values and index of bins
   * Array object will be sorted by value optionally.
   * @param {Array} bins
   * @param {Function} getValue
   * @return {Array} array of values and index lookup
   */
  getAggregatedBins(bins, props) {
    const {
      getValue = defaultGetValue,
      getPoints = defaultGetPoints,
      getIndex = defaultGetIndex,
      filterData
    } = props;

    const hasFilter = typeof filterData === 'function';
    const binCount = bins.length;
    const aggregatedBins = [];
    let index = 0;

    for (let binIndex = 0; binIndex < binCount; binIndex++) {
      const bin = bins[binIndex];
      const points = getPoints(bin);
      const i = getIndex(bin);

      const filteredPoints = hasFilter ? points.filter(filterData) : points;

      bin.filteredPoints = hasFilter ? filteredPoints : null;

      const value = filteredPoints.length ? getValue(filteredPoints) : null;

      if (value !== null && value !== undefined) {
        // filter bins if value is null or undefined
        aggregatedBins[index] = {
          i: Number.isFinite(i) ? i : binIndex,
          value,
          counts: filteredPoints.length
        };
        index++;
      }
    }
    return aggregatedBins;
  }

  _percentileToIndex(percentileRange) {
    const len = this.sortedBins.length;
    if (len < 2) {
      return [0, 0];
    }

    const [lower, upper] = percentileRange.map(n => Object(_scale_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(n, 0, 100));

    const lowerIdx = Math.ceil((lower / 100) * (len - 1));
    const upperIdx = Math.floor((upper / 100) * (len - 1));

    return [lowerIdx, upperIdx];
  }

  /**
   * Get a mapping from cell/hexagon index to sorted bin
   * This is used to retrieve bin value for color calculation
   * @return {Object} bin index to aggregatedBins
   */
  getBinMap() {
    const binMap = {};
    for (const bin of this.aggregatedBins) {
      binMap[bin.i] = bin;
    }
    return binMap;
  }

  // Private

  /**
   * Get ths max count of all bins
   * @return {Number | Boolean} max count
   */
  _updateMinMaxValues() {
    let maxCount = 0;
    let maxValue = 0;
    let minValue = MAX_32_BIT_FLOAT;
    let totalCount = 0;
    for (const x of this.aggregatedBins) {
      maxCount = maxCount > x.counts ? maxCount : x.counts;
      maxValue = maxValue > x.value ? maxValue : x.value;
      minValue = minValue < x.value ? minValue : x.value;
      totalCount += x.counts;
    }
    this.maxCount = maxCount;
    this.maxValue = maxValue;
    this.minValue = minValue;
    this.totalCount = totalCount;
  }

  /**
   * Get range of values of all bins
   * @param {Number[]} range
   * @param {Number} range[0] - lower bound
   * @param {Number} range[1] - upper bound
   * @return {Array} array of new value range
   */
  getValueRange(percentileRange) {
    if (!this.sortedBins) {
      this.sortedBins = this.aggregatedBins.sort((a, b) => a.value - b.value);
    }
    if (!this.sortedBins.length) {
      return [];
    }
    let lowerIdx = 0;
    let upperIdx = this.sortedBins.length - 1;

    if (Array.isArray(percentileRange)) {
      const idxRange = this._percentileToIndex(percentileRange);
      lowerIdx = idxRange[0];
      upperIdx = idxRange[1];
    }

    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
  }

  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {
    if (!this.sortedBins) {
      this.sortedBins = this.aggregatedBins.sort((a, b) => a.value - b.value);
    }
    if (!this.sortedBins.length) {
      return [];
    }
    const indexEdge = this._percentileToIndex([lower, upper]);

    return this._getScaleDomain(scale, indexEdge);
  }

  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {
    const bins = this.sortedBins;

    switch (scaleType) {
      case 'quantize':
      case 'linear':
        return [bins[lowerIdx].value, bins[upperIdx].value];

      case 'quantile':
        return Object(_scale_utils__WEBPACK_IMPORTED_MODULE_0__["getQuantileDomain"])(bins.slice(lowerIdx, upperIdx + 1), d => d.value);

      case 'ordinal':
        return Object(_scale_utils__WEBPACK_IMPORTED_MODULE_0__["getOrdinalDomain"])(bins, d => d.value);

      default:
        return [bins[lowerIdx].value, bins[upperIdx].value];
    }
  }
}


/***/ }),

/***/ "./src/utils/color-utils.js":
/*!**********************************!*\
  !*** ./src/utils/color-utils.js ***!
  \**********************************/
/*! exports provided: defaultColorRange, colorRangeToFlatArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultColorRange", function() { return defaultColorRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorRangeToFlatArray", function() { return colorRangeToFlatArray; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

const defaultColorRange = [
  [255, 255, 178],
  [254, 217, 118],
  [254, 178, 76],
  [253, 141, 60],
  [240, 59, 32],
  [189, 0, 38]
];

// Converts a colorRange array to a flat array with 4 components per color
function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {
  let flatArray;

  if (Number.isFinite(colorRange[0])) {
    // its already a flat array.
    flatArray = new ArrayType(colorRange);
  } else {
    // flatten it
    flatArray = new ArrayType(colorRange.length * 4);
    let index = 0;

    for (let i = 0; i < colorRange.length; i++) {
      const color = colorRange[i];
      flatArray[index++] = color[0];
      flatArray[index++] = color[1];
      flatArray[index++] = color[2];
      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
    }
  }

  if (normalize) {
    for (let i = 0; i < flatArray.length; i++) {
      flatArray[i] /= 255;
    }
  }
  return flatArray;
}


/***/ }),

/***/ "./src/utils/cpu-aggregator.js":
/*!*************************************!*\
  !*** ./src/utils/cpu-aggregator.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CPUAggregator; });
/* harmony import */ var _bin_sorter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bin-sorter */ "./src/utils/bin-sorter.js");
/* harmony import */ var _scale_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scale-utils */ "./src/utils/scale-utils.js");
/* harmony import */ var _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




function nop() {}

const dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];
const defaultDimensions = [
  {
    key: 'fillColor',
    accessor: 'getFillColor',
    pickingInfo: 'colorValue',
    getBins: {
      triggers: {
        value: {
          prop: 'getColorValue',
          updateTrigger: 'getColorValue'
        },
        weight: {
          prop: 'getColorWeight',
          updateTrigger: 'getColorWeight'
        },
        aggregation: {
          prop: 'colorAggregation'
        },
        filterData: {
          prop: '_filterData',
          updateTrigger: '_filterData'
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: 'lowerPercentile'
        },
        upperPercentile: {
          prop: 'upperPercentile'
        },
        scaleType: {
          prop: 'colorScaleType'
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: {prop: 'colorDomain'},
        range: {prop: 'colorRange'}
      },
      onSet: {
        props: 'onSetColorDomain'
      }
    },
    nullValue: [0, 0, 0, 0]
  },
  {
    key: 'elevation',
    accessor: 'getElevation',
    pickingInfo: 'elevationValue',
    getBins: {
      triggers: {
        value: {
          prop: 'getElevationValue',
          updateTrigger: 'getElevationValue'
        },
        weight: {
          prop: 'getElevationWeight',
          updateTrigger: 'getElevationWeight'
        },
        aggregation: {
          prop: 'elevationAggregation'
        },
        filterData: {
          prop: '_filterData',
          updateTrigger: '_filterData'
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: 'elevationLowerPercentile'
        },
        upperPercentile: {
          prop: 'elevationUpperPercentile'
        },
        scaleType: {
          prop: 'elevationScaleType'
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: {prop: 'elevationDomain'},
        range: {prop: 'elevationRange'}
      },
      onSet: {
        props: 'onSetElevationDomain'
      }
    },
    nullValue: -1
  }
];
const defaultGetCellSize = props => props.cellSize;
class CPUAggregator {
  constructor(opts) {
    this.state = {
      layerData: {},
      dimensions: {
        // color: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // },
        // elevation: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // }
      }
    };
    this.changeFlags = {};
    this.dimensionUpdaters = {};

    this._getCellSize = opts.getCellSize || defaultGetCellSize;
    this._getAggregator = opts.getAggregator;
    this._addDimension(opts.dimensions || defaultDimensions);
  }

  static defaultDimensions() {
    return defaultDimensions;
  }

  updateState(opts, aggregationParams) {
    const {oldProps, props, changeFlags} = opts;
    this.updateGetValueFuncs(oldProps, props, changeFlags);
    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);
    let aggregationDirty = false;
    if (changeFlags.dataChanged || reprojectNeeded) {
      // project data into bin and aggregate wegiths per bin
      this.getAggregatedData(props, aggregationParams);
      aggregationDirty = true;
    } else {
      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];
      // this here is layer
      dimensionChanges.forEach(f => typeof f === 'function' && f());
      aggregationDirty = true;
    }
    this.setState({aggregationDirty});

    return this.state;
  }

  // Update private state
  setState(updateObject) {
    this.state = Object.assign({}, this.state, updateObject);
  }

  // Update private state.dimensions
  setDimensionState(key, updateObject) {
    this.setState({
      dimensions: Object.assign({}, this.state.dimensions, {
        [key]: Object.assign({}, this.state.dimensions[key], updateObject)
      })
    });
  }

  normalizeResult(result = {}) {
    // support previous hexagonAggregator API
    if (result.hexagons) {
      return Object.assign({data: result.hexagons}, result);
    } else if (result.layerData) {
      return Object.assign({data: result.layerData}, result);
    }

    return result;
  }

  getAggregatedData(props, aggregationParams) {
    const aggregator = this._getAggregator(props);

    const result = aggregator(props, aggregationParams);
    this.setState({
      layerData: this.normalizeResult(result)
    });
    this.changeFlags = {
      layerData: true
    };
    this.getSortedBins(props);
  }

  updateGetValueFuncs(oldProps, props, changeFlags) {
    for (const key in this.dimensionUpdaters) {
      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;
      let getValue = props[value.prop];
      const getValueChanged = this.needUpdateDimensionStep(
        this.dimensionUpdaters[key].getBins,
        oldProps,
        props,
        changeFlags
      );

      if (getValueChanged && getValue === null) {
        // If `getValue` is not provided from props, build it with aggregation and weight.
        getValue = Object(_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_2__["getValueFunc"])(props[aggregation.prop], props[weight.prop]);
      }

      if (getValue) {
        this.setDimensionState(key, {getValue});
      }
    }
  }

  needsReProjectPoints(oldProps, props, changeFlags) {
    return (
      this._getCellSize(oldProps) !== this._getCellSize(props) ||
      this._getAggregator(oldProps) !== this._getAggregator(props) ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))
    );
  }

  // Adds dimensions
  addDimension(dimensions) {
    this._addDimension(dimensions);
  }

  _addDimension(dimensions = []) {
    dimensions.forEach(dimension => {
      const {key} = dimension;
      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);
      this.state.dimensions[key] = {
        getValue: null,
        domain: null,
        sortedBins: null,
        scaleFunc: nop
      };
    });
  }

  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {
    return {
      key,
      accessor,
      pickingInfo,
      getBins: Object.assign({updater: this.getDimensionSortedBins}, getBins),
      getDomain: Object.assign({updater: this.getDimensionValueDomain}, getDomain),
      getScaleFunc: Object.assign({updater: this.getDimensionScale}, getScaleFunc),
      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)
    };
  }

  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {
    // whether need to update current dimension step
    // dimension step is the value, domain, scaleFunction of each dimension
    // each step is an object with properties links to layer prop and whether the prop is
    // controlled by updateTriggers
    // getBins: {
    //   value: {
    //     prop: 'getElevationValue',
    //     updateTrigger: 'getElevationValue'
    //   },
    //   weight: {
    //     prop: 'getElevationWeight',
    //     updateTrigger: 'getElevationWeight'
    //   },
    //   aggregation: {
    //     prop: 'elevationAggregation'
    //   }
    // }
    return Object.values(dimensionStep.triggers).some(item => {
      if (item.updateTrigger) {
        // check based on updateTriggers change first
        return (
          changeFlags.updateTriggersChanged &&
          (changeFlags.updateTriggersChanged.all ||
            changeFlags.updateTriggersChanged[item.updateTrigger])
        );
      }
      // fallback to direct comparison
      return oldProps[item.prop] !== props[item.prop];
    });
  }

  getDimensionChanges(oldProps, props, changeFlags) {
    // const {dimensionUpdaters} = this.state;
    const updaters = [];

    // get dimension to be updated
    for (const key in this.dimensionUpdaters) {
      // return the first triggered updater for each dimension
      const needUpdate = dimensionSteps.find(step =>
        this.needUpdateDimensionStep(
          this.dimensionUpdaters[key][step],
          oldProps,
          props,
          changeFlags
        )
      );

      if (needUpdate) {
        updaters.push(
          this.dimensionUpdaters[key][needUpdate].updater.bind(
            this,
            props,
            this.dimensionUpdaters[key]
          )
        );
      }
    }

    return updaters.length ? updaters : null;
  }

  getUpdateTriggers(props) {
    const _updateTriggers = props.updateTriggers || {};
    const updateTriggers = {};

    for (const key in this.dimensionUpdaters) {
      const {accessor} = this.dimensionUpdaters[key];
      // fold dimension triggers into each accessor
      updateTriggers[accessor] = {};

      dimensionSteps.forEach(step => {
        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(
          ({prop, updateTrigger}) => {
            if (updateTrigger) {
              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight
              // and updateTriggers is passed in from layer prop
              // fold the updateTriggers into accessor
              const fromProp = _updateTriggers[updateTrigger];
              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {
                // if updateTrigger is an object spread it
                Object.assign(updateTriggers[accessor], fromProp);
              } else if (fromProp !== undefined) {
                updateTriggers[accessor][prop] = fromProp;
              }
            } else {
              // if prop is not based on updateTrigger
              updateTriggers[accessor][prop] = props[prop];
            }
          }
        );
      });
    }

    return updateTriggers;
  }

  getSortedBins(props) {
    for (const key in this.dimensionUpdaters) {
      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);
    }
  }

  getDimensionSortedBins(props, dimensionUpdater) {
    const {key} = dimensionUpdater;
    const {getValue} = this.state.dimensions[key];

    const sortedBins = new _bin_sorter__WEBPACK_IMPORTED_MODULE_0__["default"](this.state.layerData.data || [], {
      getValue,
      filterData: props._filterData
    });
    this.setDimensionState(key, {sortedBins});
    this.getDimensionValueDomain(props, dimensionUpdater);
  }

  getDimensionValueDomain(props, dimensionUpdater) {
    const {getDomain, key} = dimensionUpdater;
    const {
      triggers: {lowerPercentile, upperPercentile, scaleType}
    } = getDomain;
    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(
      props[scaleType.prop],
      [props[lowerPercentile.prop], props[upperPercentile.prop]]
    );

    this.setDimensionState(key, {valueDomain});
    this.getDimensionScale(props, dimensionUpdater);
  }

  getDimensionScale(props, dimensionUpdater) {
    const {key, getScaleFunc, getDomain} = dimensionUpdater;
    const {domain, range} = getScaleFunc.triggers;
    const {scaleType} = getDomain.triggers;
    const {onSet} = getScaleFunc;
    const dimensionRange = props[range.prop];
    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
    const getScaleFunction = Object(_scale_utils__WEBPACK_IMPORTED_MODULE_1__["getScaleFunctionByScaleType"])(scaleType && props[scaleType.prop]);
    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);

    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {
      props[onSet.props](scaleFunc.domain());
    }

    this.setDimensionState(key, {scaleFunc});
  }

  getSubLayerDimensionAttribute(key, nullValue) {
    return cell => {
      const {sortedBins, scaleFunc} = this.state.dimensions[key];
      const bin = sortedBins.binMap[cell.index];

      if (bin && bin.counts === 0) {
        // no points left in bin after filtering
        return nullValue;
      }
      const cv = bin && bin.value;
      const domain = scaleFunc.domain();

      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];

      // if cell value is outside domain, set alpha to 0
      return isValueInDomain ? scaleFunc(cv) : nullValue;
    };
  }

  getSubLayerAccessors(props) {
    const accessors = {};
    for (const key in this.dimensionUpdaters) {
      const {accessor} = this.dimensionUpdaters[key];
      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);
    }

    return accessors;
  }

  getPickingInfo({info}) {
    const isPicked = info.picked && info.index > -1;
    let object = null;

    if (isPicked) {
      // const {sortedColorBins, sortedElevationBins} = this.state;

      const cell = this.state.layerData.data[info.index];

      const binInfo = {};
      for (const key in this.dimensionUpdaters) {
        const {pickingInfo} = this.dimensionUpdaters[key];
        const {sortedBins} = this.state.dimensions[key];
        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
        binInfo[pickingInfo] = value;
      }

      object = Object.assign(binInfo, cell, {
        points: cell.filteredPoints || cell.points
      });
    }

    // add bin colorValue and elevationValue to info
    return Object.assign(info, {
      picked: Boolean(object),
      // override object with picked cell
      object
    });
  }

  getAccessor(dimensionKey) {
    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
      return nop;
    }
    return this.dimensionUpdaters[dimensionKey].attributeAccessor;
  }
}


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js":
/*!*****************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs

precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  if (textureColor.a == 0.) {
    discard;
  }
  fragColor.rgb = textureColor.rgb;
  // if combineMinMax is true, use Alpha channel for first weights min value.
  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`);


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js":
/*!*****************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64

in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;

void main(void) {
  // Map each position to single pixel
  vec2 pos = vec2(-1.0, -1.0);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / vec2(gridSize);
  pos = pos + offset;

  gl_Position = vec4(pos, 0.0, 1.0);

  int yIndex = gl_InstanceID / gridSize[0];
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 yIndexFP64 = vec2(float(yIndex), 0.);
  vec2 xIndexFP64 = vec2(float(xIndex), 0.);
  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);

  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);

  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`);


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js":
/*!*********************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME gpu-aggregation-to-grid-fs

precision highp float;

varying vec3 vWeights;

void main(void) {
  gl_FragColor = vec4(vWeights, 1.0);
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`);


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js":
/*!*********************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME gpu-aggregation-to-grid-vs

attribute vec3 positions;
attribute vec3 positions64Low;
attribute vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;

varying vec3 vWeights;

vec2 project_to_pixel(vec4 pos) {
  vec4 result;
  pos.xy = pos.xy/pos.w;
  result = pos + vec4(translation, 0., 0.);
  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
  return result.xy;
}

void main(void) {

  vWeights = weights;

  vec4 windowPos = vec4(positions, 1.);
  if (projectPoints) {
    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
  }

  vec2 pos = project_to_pixel(windowPos);

  vec2 pixelXY64[2];
  pixelXY64[0] = vec2(pos.x, 0.);
  pixelXY64[1] = vec2(pos.y, 0.);

  // Transform (0,0):windowSize -> (0, 0): gridSize
  vec2 gridXY64[2];
  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
  float x = floor(gridXY64[0].x);
  float y = floor(gridXY64[1].x);
  pos = vec2(x, y);

  // Transform (0,0):gridSize -> (-1, -1):(1,1)
  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / gridSize;
  pos = pos + offset;


  gl_Position = vec4(pos, 0.0, 1.0);
}
`);


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js":
/*!*************************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js ***!
  \*************************************************************************/
/*! exports provided: DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, ELEMENTCOUNT, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE, WEIGHT_SIZE, MAX_MIN_TEXTURE_OPTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RUN_PARAMS", function() { return DEFAULT_RUN_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_32_BIT_FLOAT", function() { return MAX_32_BIT_FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_BLEND_EQUATION", function() { return MIN_BLEND_EQUATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_BLEND_EQUATION", function() { return MAX_BLEND_EQUATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_MIN_BLEND_EQUATION", function() { return MAX_MIN_BLEND_EQUATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQUATION_MAP", function() { return EQUATION_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELEMENTCOUNT", function() { return ELEMENTCOUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_WEIGHT_PARAMS", function() { return DEFAULT_WEIGHT_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PIXEL_SIZE", function() { return PIXEL_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEIGHT_SIZE", function() { return WEIGHT_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_MIN_TEXTURE_OPTS", function() { return MAX_MIN_TEXTURE_OPTS; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");



const DEFAULT_RUN_PARAMS = {
  projectPoints: false,
  viewport: null,
  createBufferObjects: true,
  moduleSettings: {}
};

const MAX_32_BIT_FLOAT = 3.402823466e38;
const MIN_BLEND_EQUATION = [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MIN, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD];
const MAX_BLEND_EQUATION = [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD];
const MAX_MIN_BLEND_EQUATION = [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MIN];
const EQUATION_MAP = {
  [_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__["AGGREGATION_OPERATION"].SUM]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD,
  [_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__["AGGREGATION_OPERATION"].MEAN]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD,
  [_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__["AGGREGATION_OPERATION"].MIN]: MIN_BLEND_EQUATION,
  [_aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__["AGGREGATION_OPERATION"].MAX]: MAX_BLEND_EQUATION
};

const ELEMENTCOUNT = 4;
const DEFAULT_WEIGHT_PARAMS = {
  size: 1,
  operation: _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_1__["AGGREGATION_OPERATION"].SUM,
  needMin: false,
  needMax: false,
  combineMaxMin: false
};

const PIXEL_SIZE = 4; // RGBA32F
const WEIGHT_SIZE = 3;

const MAX_MIN_TEXTURE_OPTS = {
  format: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F,
  type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT,
  border: 0,
  mipmaps: false,
  parameters: {
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
    [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST
  },
  dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
  width: 1,
  height: 1
};


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js":
/*!***************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GPUGridAggregator; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gpu-grid-aggregator-constants */ "./src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js");
/* harmony import */ var _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../aggregation-operation-utils */ "./src/utils/aggregation-operation-utils.js");
/* harmony import */ var _aggregate_to_grid_vs_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./aggregate-to-grid-vs.glsl */ "./src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js");
/* harmony import */ var _aggregate_to_grid_fs_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./aggregate-to-grid-fs.glsl */ "./src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js");
/* harmony import */ var _aggregate_all_vs_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./aggregate-all-vs.glsl */ "./src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js");
/* harmony import */ var _aggregate_all_fs_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./aggregate-all-fs.glsl */ "./src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js");
/* harmony import */ var _transform_mean_vs_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transform-mean-vs.glsl */ "./src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js");
/* harmony import */ var _resource_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../resource-utils.js */ "./src/utils/resource-utils.js");
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
















const BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];
const ARRAY_BUFFER_MAP = {
  maxData: 'maxBuffer',
  minData: 'minBuffer',
  maxMinData: 'maxMinBuffer'
};

const REQUIRED_FEATURES = [
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].WEBGL2, // TODO: Remove after trannsform refactor
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].COLOR_ATTACHMENT_RGBA32F,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].BLEND_EQUATION_MINMAX,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].FLOAT_BLEND,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].TEXTURE_FLOAT
];

class GPUGridAggregator {
  // Decode and return aggregation data of given pixel.
  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {
    const index = pixelIndex * _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["PIXEL_SIZE"];
    const results = {};
    if (aggregationData) {
      results.cellCount = aggregationData[index + 3];
      results.cellWeight = aggregationData[index];
    }
    if (maxMinData) {
      results.maxCellWieght = maxMinData[0];
      results.minCellWeight = maxMinData[3];
    } else {
      if (maxData) {
        results.maxCellWieght = maxData[0];
        results.totalCount = maxData[3];
      }
      if (minData) {
        results.minCellWeight = minData[0];
        results.totalCount = maxData[3];
      }
    }
    return results;
  }

  // Decodes and retuns counts and weights of all cells
  static getCellData({countsData, size = 1}) {
    const numCells = countsData.length / 4;
    const cellWeights = new Float32Array(numCells * size);
    const cellCounts = new Uint32Array(numCells);
    for (let i = 0; i < numCells; i++) {
      // weights in RGB channels
      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {
        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];
      }
      // count in Alpha channel
      cellCounts[i] = countsData[i * 4 + 3];
    }
    return {cellCounts, cellWeights};
  }

  static isSupported(gl) {
    return Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, REQUIRED_FEATURES);
  }

  // DEBUG ONLY
  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {
  //   if (aggregationBuffer) {
  //     console.log('Aggregation Data:');
  //     const agrData = aggregationBuffer.getData();
  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {
  //       if (agrData[index + 3] > 0) {
  //         console.log(
  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${
  //             agrData[index + 2]
  //           } count: ${agrData[index + 3]}`
  //         );
  //         limit--;
  //       }
  //     }
  //   }
  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};
  //   for (const key in obj) {
  //     if (obj[key]) {
  //       const data = obj[key].getData();
  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);
  //     }
  //   }
  // }

  constructor(gl, opts = {}) {
    this.id = opts.id || 'gpu-grid-aggregator';
    this.gl = gl;
    this.state = {
      // per weight GPU resources
      weightAttributes: {},
      textures: {},
      meanTextures: {},
      buffers: {},
      framebuffers: {},
      maxMinFramebuffers: {},
      minFramebuffers: {},
      maxFramebuffers: {},
      equations: {},

      // common resources to be deleted
      resources: {},

      // results
      results: {}
    };
    this._hasGPUSupport =
      Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) && // gl_InstanceID usage in min/max calculation shaders
      Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(
        this.gl,
        _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].BLEND_EQUATION_MINMAX, // set min/max blend modes
        _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].COLOR_ATTACHMENT_RGBA32F, // render to float texture
        _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].TEXTURE_FLOAT // sample from a float texture
      );
    if (this._hasGPUSupport) {
      this._setupModels();
    }
  }

  // Delete owned resources.
  /* eslint no-unused-expressions: ["error", { "allowShortCircuit": true }] */
  delete() {
    const {gridAggregationModel, allAggregationModel, meanTransform} = this;
    const {
      textures,
      framebuffers,
      maxMinFramebuffers,
      minFramebuffers,
      maxFramebuffers,
      meanTextures,
      resources
    } = this.state;

    gridAggregationModel && gridAggregationModel.delete();
    allAggregationModel && allAggregationModel.delete();
    meanTransform && meanTransform.delete();

    deleteResources([
      framebuffers,
      textures,
      maxMinFramebuffers,
      minFramebuffers,
      maxFramebuffers,
      meanTextures,
      resources
    ]);
  }

  // Perform aggregation and retun the results
  run(opts = {}) {
    // reset results
    this.setState({results: {}});
    const aggregationParams = this._normalizeAggregationParams(opts);
    if (!this._hasGPUSupport) {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["log"].log(1, 'GPUGridAggregator: not supported')();
    }
    return this._runAggregation(aggregationParams);
  }

  // Reads aggregation data into JS Array object
  // For WebGL1, data is available in JS Array objects already.
  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.
  getData(weightId) {
    const data = {};
    const results = this.state.results;
    if (!results[weightId].aggregationData) {
      // cache the results if reading from the buffer (WebGL2 path)
      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();
    }
    data.aggregationData = results[weightId].aggregationData;

    // Check for optional results
    for (const arrayName in ARRAY_BUFFER_MAP) {
      const bufferName = ARRAY_BUFFER_MAP[arrayName];

      if (results[weightId][arrayName] || results[weightId][bufferName]) {
        // cache the result
        results[weightId][arrayName] =
          results[weightId][arrayName] || results[weightId][bufferName].getData();
        data[arrayName] = results[weightId][arrayName];
      }
    }
    return data;
  }

  updateShaders(shaderOptions = {}) {
    this.setState({shaderOptions, modelDirty: true});
  }

  // PRIVATE

  _normalizeAggregationParams(opts) {
    const aggregationParams = Object.assign({}, _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_RUN_PARAMS"], opts);
    const {weights} = aggregationParams;
    if (weights) {
      aggregationParams.weights = normalizeWeightParams(weights);
    }
    return aggregationParams;
  }

  // Update priveate state
  setState(updateObject) {
    Object.assign(this.state, updateObject);
  }

  // GPU Aggregation methods

  _getAggregateData(opts) {
    const results = {};
    const {
      textures,
      framebuffers,
      maxMinFramebuffers,
      minFramebuffers,
      maxFramebuffers,
      resources
    } = this.state;
    const {weights} = opts;

    for (const id in weights) {
      results[id] = {};
      const {needMin, needMax, combineMaxMin} = weights[id];
      results[id].aggregationTexture = textures[id];
      results[id].aggregationBuffer = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"])(framebuffers[id], {
        target: weights[id].aggregationBuffer, // update if a buffer is provided
        sourceType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT
      });
      if (needMin && needMax && combineMaxMin) {
        results[id].maxMinBuffer = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"])(maxMinFramebuffers[id], {
          target: weights[id].maxMinBuffer, // update if a buffer is provided
          sourceType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT
        });
        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];
      } else {
        if (needMin) {
          results[id].minBuffer = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"])(minFramebuffers[id], {
            target: weights[id].minBuffer, // update if a buffer is provided
            sourceType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT
          });
          results[id].minTexture = resources[`${id}-minTexture`];
        }
        if (needMax) {
          results[id].maxBuffer = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"])(maxFramebuffers[id], {
            target: weights[id].maxBuffer, // update if a buffer is provided
            sourceType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT
          });
          results[id].maxTexture = resources[`${id}-maxTexture`];
        }
      }
    }
    this._trackGPUResultBuffers(results, weights);
    return results;
  }

  _renderAggregateData(opts) {
    const {
      cellSize,
      projectPoints,
      attributes,
      moduleSettings,
      numCol,
      numRow,
      weights,
      translation,
      scaling
    } = opts;
    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;

    const gridSize = [numCol, numRow];
    const parameters = {
      blend: true,
      depthTest: false,
      blendFunc: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE]
    };
    const uniforms = {
      cellSize,
      gridSize,
      projectPoints,
      translation,
      scaling
    };

    for (const id in weights) {
      const {needMin, needMax} = weights[id];
      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
      this._renderToWeightsTexture({
        id,
        parameters,
        moduleSettings,
        uniforms,
        gridSize,
        attributes,
        weights
      });
      if (combineMaxMin) {
        this._renderToMaxMinTexture({
          id,
          parameters: Object.assign({}, parameters, {blendEquation: _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_MIN_BLEND_EQUATION"]}),
          gridSize,
          minOrMaxFb: maxMinFramebuffers[id],
          clearParams: {clearColor: [0, 0, 0, _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"]]},
          combineMaxMin
        });
      } else {
        if (needMin) {
          this._renderToMaxMinTexture({
            id,
            parameters: Object.assign({}, parameters, {blendEquation: _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MIN_BLEND_EQUATION"]}),
            gridSize,
            minOrMaxFb: minFramebuffers[id],
            clearParams: {clearColor: [_gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], 0]},
            combineMaxMin
          });
        }
        if (needMax) {
          this._renderToMaxMinTexture({
            id,
            parameters: Object.assign({}, parameters, {blendEquation: _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_BLEND_EQUATION"]}),
            gridSize,
            minOrMaxFb: maxFramebuffers[id],
            clearParams: {clearColor: [0, 0, 0, 0]},
            combineMaxMin
          });
        }
      }
    }
  }

  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture
  _renderToMaxMinTexture(opts) {
    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;
    const {framebuffers} = this.state;
    const {gl, allAggregationModel} = this;

    minOrMaxFb.bind();
    gl.viewport(0, 0, gridSize[0], gridSize[1]);
    Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, clearParams, () => {
      gl.clear(gl.COLOR_BUFFER_BIT);
    });
    allAggregationModel.draw({
      parameters,
      uniforms: {
        uSampler: framebuffers[id].texture,
        gridSize,
        combineMaxMin
      }
    });
    minOrMaxFb.unbind();
  }

  // render all data points to aggregate weights
  _renderToWeightsTexture(opts) {
    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;
    const {framebuffers, equations, weightAttributes} = this.state;
    const {gl, gridAggregationModel} = this;
    const {operation} = weights[id];

    framebuffers[id].bind();
    gl.viewport(0, 0, gridSize[0], gridSize[1]);
    const clearColor =
      operation === _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"].MIN
        ? [_gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["MAX_32_BIT_FLOAT"], 0]
        : [0, 0, 0, 0];
    Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, {clearColor}, () => {
      gl.clear(gl.COLOR_BUFFER_BIT);
    });

    const attributes = {weights: weightAttributes[id]};
    gridAggregationModel.draw({
      parameters: Object.assign({}, parameters, {blendEquation: equations[id]}),
      moduleSettings,
      uniforms,
      attributes
    });
    framebuffers[id].unbind();

    if (operation === _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"].MEAN) {
      const {meanTextures, textures} = this.state;
      const transformOptions = {
        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data
        _targetTexture: textures[id], // store mean values,
        elementCount: textures[id].width * textures[id].height
      };
      if (this.meanTransform) {
        this.meanTransform.update(transformOptions);
      } else {
        this.meanTransform = getMeanTransform(gl, transformOptions);
      }
      this.meanTransform.run({
        parameters: {
          blend: false,
          depthTest: false
        }
      });

      // update framebuffer with mean results so readPixelsToBuffer returns mean values
      framebuffers[id].attach({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]: textures[id]});
    }
  }

  _runAggregation(opts) {
    this._updateModels(opts);
    this._setupFramebuffers(opts);
    this._renderAggregateData(opts);
    const results = this._getAggregateData(opts);
    this.setState({results});
    return results;
  }

  // set up framebuffer for each weight
  /* eslint-disable complexity, max-depth, max-statements*/
  _setupFramebuffers(opts) {
    const {
      textures,
      framebuffers,
      maxMinFramebuffers,
      minFramebuffers,
      maxFramebuffers,
      meanTextures,
      equations
    } = this.state;
    const {weights} = opts;
    const {numCol, numRow} = opts;
    const framebufferSize = {width: numCol, height: numRow};
    for (const id in weights) {
      const {needMin, needMax, combineMaxMin, operation} = weights[id];
      textures[id] =
        weights[id].aggregationTexture ||
        textures[id] ||
        Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFloatTexture"])(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});
      textures[id].resize(framebufferSize);
      let texture = textures[id];
      if (operation === _aggregation_operation_utils__WEBPACK_IMPORTED_MODULE_3__["AGGREGATION_OPERATION"].MEAN) {
        // For MEAN, we first aggregatet into a temp texture
        meanTextures[id] =
          meanTextures[id] ||
          Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFloatTexture"])(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});
        meanTextures[id].resize(framebufferSize);
        texture = meanTextures[id];
      }
      if (framebuffers[id]) {
        framebuffers[id].attach({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]: texture});
      } else {
        framebuffers[id] = Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFramebuffer"])(this.gl, {
          id: `${id}-fb`,
          width: numCol,
          height: numRow,
          texture
        });
      }
      framebuffers[id].resize(framebufferSize);
      equations[id] = _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["EQUATION_MAP"][operation] || _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["EQUATION_MAP"].SUM;
      // For min/max framebuffers will use default size 1X1
      if (needMin || needMax) {
        if (needMin && needMax && combineMaxMin) {
          if (!maxMinFramebuffers[id]) {
            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);
            maxMinFramebuffers[id] = Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFramebuffer"])(this.gl, {id: `${id}-maxMinFb`, texture});
          }
        } else {
          if (needMin) {
            if (!minFramebuffers[id]) {
              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);
              minFramebuffers[id] = Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFramebuffer"])(this.gl, {
                id: `${id}-minFb`,
                texture
              });
            }
          }
          if (needMax) {
            if (!maxFramebuffers[id]) {
              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);
              maxFramebuffers[id] = Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFramebuffer"])(this.gl, {
                id: `${id}-maxFb`,
                texture
              });
            }
          }
        }
      }
    }
  }
  /* eslint-enable complexity, max-depth, max-statements */

  _getMinMaxTexture(name) {
    const {resources} = this.state;
    if (!resources[name]) {
      resources[name] = Object(_resource_utils_js__WEBPACK_IMPORTED_MODULE_9__["getFloatTexture"])(this.gl, {id: `resourceName`});
    }
    return resources[name];
  }

  _setupModels({numCol = 0, numRow = 0} = {}) {
    const {gl} = this;
    const {shaderOptions} = this.state;
    if (this.gridAggregationModel) {
      this.gridAggregationModel.delete();
    }
    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);
    if (!this.allAggregationModel) {
      const instanceCount = numCol * numRow;
      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);
    }
  }

  // set up buffers for all weights
  _setupWeightAttributes(opts) {
    const {weightAttributes} = this.state;
    const {weights} = opts;
    for (const id in weights) {
      weightAttributes[id] = opts.attributes[id];
    }
  }

  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.
  /* eslint-disable max-depth */
  _trackGPUResultBuffers(results, weights) {
    const {resources} = this.state;
    for (const id in results) {
      if (results[id]) {
        for (const bufferName of BUFFER_NAMES) {
          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {
            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object
            // collect the new buffer for garabge collection
            const name = `gpu-result-${id}-${bufferName}`;
            if (resources[name]) {
              resources[name].delete();
            }
            resources[name] = results[id][bufferName];
          }
        }
      }
    }
  }
  /* eslint-enable max-depth */

  _updateModels(opts) {
    const {vertexCount, attributes, numCol, numRow} = opts;
    const {modelDirty} = this.state;

    if (modelDirty) {
      this._setupModels(opts);
      this.setState({modelDirty: false});
    }

    // this maps color/elevation to weight name.
    this._setupWeightAttributes(opts);

    this.gridAggregationModel.setVertexCount(vertexCount);
    this.gridAggregationModel.setAttributes(attributes);

    this.allAggregationModel.setInstanceCount(numCol * numRow);
  }
}

// HELPER METHODS

function normalizeWeightParams(weights) {
  const result = {};
  for (const id in weights) {
    result[id] = Object.assign({}, _gpu_grid_aggregator_constants__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_WEIGHT_PARAMS"], weights[id]);
  }
  return result;
}

function deleteResources(resources) {
  resources = Array.isArray(resources) ? resources : [resources];
  resources.forEach(obj => {
    for (const name in obj) {
      obj[name].delete();
    }
  });
}

function getAggregationModel(gl, shaderOptions) {
  const shaders = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["_mergeShaders"])(
    {
      vs: _aggregate_to_grid_vs_glsl__WEBPACK_IMPORTED_MODULE_4__["default"],
      fs: _aggregate_to_grid_fs_glsl__WEBPACK_IMPORTED_MODULE_5__["default"],
      modules: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["fp64arithmetic"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["project32"]]
    },
    shaderOptions
  );

  return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Model"](gl, {
    id: 'Gird-Aggregation-Model',
    vertexCount: 1,
    drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POINTS,
    ...shaders
  });
}

function getAllAggregationModel(gl, instanceCount) {
  return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Model"](gl, {
    id: 'All-Aggregation-Model',
    vs: _aggregate_all_vs_glsl__WEBPACK_IMPORTED_MODULE_6__["default"],
    fs: _aggregate_all_fs_glsl__WEBPACK_IMPORTED_MODULE_7__["default"],
    modules: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["fp64arithmetic"]],
    vertexCount: 1,
    drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POINTS,
    isInstanced: true,
    instanceCount,
    attributes: {
      position: [0, 0]
    }
  });
}

function getMeanTransform(gl, opts) {
  return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Transform"](
    gl,
    Object.assign(
      {},
      {
        vs: _transform_mean_vs_glsl__WEBPACK_IMPORTED_MODULE_8__["default"],
        _targetTextureVarying: 'meanValues'
      },
      opts
    )
  );
}


/***/ }),

/***/ "./src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js":
/*!******************************************************************!*\
  !*** ./src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME gpu-aggregation-transform-mean-vs
attribute vec4 aggregationValues;
varying vec4 meanValues;

void main()
{
  // TODO: Use 64-bit division ?? not needed given this is aggregation ??
  bool isCellValid = bool(aggregationValues.w > 0.);
  // aggregationValues:  XYZ contain aggregated values, W contains count
  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
  meanValues.w = aggregationValues.w;
}
`);


/***/ }),

/***/ "./src/utils/grid-aggregation-utils.js":
/*!*********************************************!*\
  !*** ./src/utils/grid-aggregation-utils.js ***!
  \*********************************************/
/*! exports provided: getBoundingBox, alignToCell, getGridOffset, getGridParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingBox", function() { return getBoundingBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alignToCell", function() { return alignToCell; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGridOffset", function() { return getGridOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGridParams", function() { return getGridParams; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);

const R_EARTH = 6378000;

function toFinite(n) {
  return Number.isFinite(n) ? n : 0;
}

// Parse input data to build positions, wights and bounding box.
/* eslint-disable max-statements */
function getBoundingBox(attributes, vertexCount) {
  // TODO - value might not exist (e.g. attribute transition)
  const positions = attributes.positions.value;

  let yMin = Infinity;
  let yMax = -Infinity;
  let xMin = Infinity;
  let xMax = -Infinity;
  let y;
  let x;

  for (let i = 0; i < vertexCount; i++) {
    x = positions[i * 3];
    y = positions[i * 3 + 1];
    yMin = y < yMin ? y : yMin;
    yMax = y > yMax ? y : yMax;
    xMin = x < xMin ? x : xMin;
    xMax = x > xMax ? x : xMax;
  }

  const boundingBox = {
    xMin: toFinite(xMin),
    xMax: toFinite(xMax),
    yMin: toFinite(yMin),
    yMax: toFinite(yMax)
  };

  return boundingBox;
}
/* eslint-enable max-statements */

// Returns XY translation for positions to peform aggregation in +ve sapce
function getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {
  const {width, height} = viewport;

  // Origin to define grid
  // DEFAULT coordinate system is treated as LNGLAT
  const worldOrigin =
    coordinateSystem === _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];

  // Other coordinate systems not supported/verified yet.
  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(
    [_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].CARTESIAN, _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].LNGLAT, _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].DEFAULT].includes(
      coordinateSystem
    )
  );

  const {xMin, yMin} = boundingBox;
  return [
    // Align origin to match grid cell boundaries in CPU and GPU aggregations
    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),
    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])
  ];
}

// Aligns `inValue` to given `cellSize`
function alignToCell(inValue, cellSize) {
  const sign = inValue < 0 ? -1 : 1;

  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);

  value = Math.floor(value / cellSize) * cellSize;

  return value * sign;
}

/**
 * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space
 * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data
 * @param {number} cellSize - grid cell size in meters
 * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space
 * @returns {xOffset, yOffset} - cellSize size
 */

function getGridOffset(boundingBox, cellSize, convertToMeters = true) {
  if (!convertToMeters) {
    return {xOffset: cellSize, yOffset: cellSize};
  }

  const {yMin, yMax} = boundingBox;
  const centerLat = (yMin + yMax) / 2;

  return calculateGridLatLonOffset(cellSize, centerLat);
}

function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {
  const gridOffset = getGridOffset(
    boundingBox,
    cellSize,
    coordinateSystem !== _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].CARTESIAN
  );

  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);

  const {xMin, yMin, xMax, yMax} = boundingBox;

  const width = xMax - xMin + gridOffset.xOffset;
  const height = yMax - yMin + gridOffset.yOffset;

  const numCol = Math.ceil(width / gridOffset.xOffset);
  const numRow = Math.ceil(height / gridOffset.yOffset);
  return {gridOffset, translation, width, height, numCol, numRow};
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function calculateGridLatLonOffset(cellSize, latitude) {
  const yOffset = calculateLatOffset(cellSize);
  const xOffset = calculateLonOffset(latitude, cellSize);
  return {yOffset, xOffset};
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function calculateLatOffset(dy) {
  return (dy / R_EARTH) * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function calculateLonOffset(lat, dx) {
  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);
}


/***/ }),

/***/ "./src/utils/prop-utils.js":
/*!*********************************!*\
  !*** ./src/utils/prop-utils.js ***!
  \*********************************/
/*! exports provided: filterProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterProps", function() { return filterProps; });
// Copyright (c) 2015 - 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function filterProps(props, filterKeys) {
  const filteredProps = {};
  for (const key in props) {
    if (!filterKeys.includes(key)) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}


/***/ }),

/***/ "./src/utils/resource-utils.js":
/*!*************************************!*\
  !*** ./src/utils/resource-utils.js ***!
  \*************************************/
/*! exports provided: getFloatTexture, getFramebuffer, getFloatArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFloatTexture", function() { return getFloatTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFramebuffer", function() { return getFramebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFloatArray", function() { return getFloatArray; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);



const DEFAULT_PARAMETERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST
};

function getFloatTexture(gl, opts = {}) {
  const {
    width = 1,
    height = 1,
    data = null,
    unpackFlipY = true,
    parameters = DEFAULT_PARAMETERS
  } = opts;
  const texture = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](gl, {
    data,
    format: Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT,
    border: 0,
    mipmaps: false,
    parameters,
    dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    width,
    height,
    unpackFlipY
  });
  return texture;
}

function getFramebuffer(gl, opts) {
  const {id, width = 1, height = 1, texture} = opts;
  const fb = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](gl, {
    id,
    width,
    height,
    attachments: {
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]: texture
    }
  });

  return fb;
}

function getFloatArray(array, size, fillValue = 0) {
  if (!array || array.length < size) {
    return new Float32Array(size).fill(fillValue);
  }
  return array;
}


/***/ }),

/***/ "./src/utils/scale-utils.js":
/*!**********************************!*\
  !*** ./src/utils/scale-utils.js ***!
  \**********************************/
/*! exports provided: getScale, getQuantizeScale, getLinearScale, getQuantileScale, getOrdinalScale, quantizeScale, linearScale, unique, getLinearDomain, getQuantileDomain, getOrdinalDomain, getScaleDomain, clamp, getScaleFunctionByScaleType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScale", function() { return getScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQuantizeScale", function() { return getQuantizeScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLinearScale", function() { return getLinearScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQuantileScale", function() { return getQuantileScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrdinalScale", function() { return getOrdinalScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeScale", function() { return quantizeScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearScale", function() { return linearScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return unique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLinearDomain", function() { return getLinearDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQuantileDomain", function() { return getQuantileDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrdinalDomain", function() { return getOrdinalDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleDomain", function() { return getScaleDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleFunctionByScaleType", function() { return getScaleFunctionByScaleType; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



// a scale function wrapper just like d3-scales
function getScale(domain, range, scaleFunction) {
  const scale = scaleFunction;
  scale.domain = () => domain;
  scale.range = () => range;

  return scale;
}

// Quantize scale is similar to linear scales,
// except it uses a discrete rather than continuous range
// return a quantize scale function
function getQuantizeScale(domain, range) {
  const scaleFunction = value => quantizeScale(domain, range, value);

  return getScale(domain, range, scaleFunction);
}

// return a linear scale function
function getLinearScale(domain, range) {
  const scaleFunction = value => linearScale(domain, range, value);

  return getScale(domain, range, scaleFunction);
}

function getQuantileScale(domain, range) {
  // calculate threshold
  const sortedDomain = domain.sort(ascending);
  let i = 0;
  const n = Math.max(1, range.length);
  const thresholds = new Array(n - 1);
  while (++i < n) {
    thresholds[i - 1] = threshold(sortedDomain, i / n);
  }

  const scaleFunction = value => thresholdsScale(thresholds, range, value);
  scaleFunction.thresholds = () => thresholds;

  return getScale(domain, range, scaleFunction);
}

function ascending(a, b) {
  return a - b;
}

function threshold(domain, fraction) {
  const domainLength = domain.length;
  if (fraction <= 0 || domainLength < 2) {
    return domain[0];
  }
  if (fraction >= 1) {
    return domain[domainLength - 1];
  }

  const domainFraction = (domainLength - 1) * fraction;
  const lowIndex = Math.floor(domainFraction);
  const low = domain[lowIndex];
  const high = domain[lowIndex + 1];
  return low + (high - low) * (domainFraction - lowIndex);
}

function bisectRight(a, x) {
  let lo = 0;
  let hi = a.length;
  while (lo < hi) {
    const mid = (lo + hi) >>> 1;
    if (ascending(a[mid], x) > 0) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return lo;
}

// return a quantize scale function
function thresholdsScale(thresholds, range, value) {
  return range[bisectRight(thresholds, value)];
}

// ordinal Scale
function ordinalScale(domain, domainMap, range, value) {
  const key = `${value}`;
  let d = domainMap.get(key);
  if (d === undefined) {
    // update the domain
    d = domain.push(value);
    domainMap.set(key, d);
  }
  return range[(d - 1) % range.length];
}

function getOrdinalScale(domain, range) {
  const domainMap = new Map();
  const uniqueDomain = [];
  for (const d of domain) {
    const key = `${d}`;
    if (!domainMap.has(key)) {
      domainMap.set(key, uniqueDomain.push(d));
    }
  }

  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);

  return getScale(domain, range, scaleFunction);
}

// Quantize scale is similar to linear scales,
// except it uses a discrete rather than continuous range
function quantizeScale(domain, range, value) {
  const domainRange = domain[1] - domain[0];
  if (domainRange <= 0) {
    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn('quantizeScale: invalid domain, returning range[0]')();
    return range[0];
  }
  const step = domainRange / range.length;
  const idx = Math.floor((value - domain[0]) / step);
  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);

  return range[clampIdx];
}

// Linear scale maps continuous domain to continuous range
function linearScale(domain, range, value) {
  return ((value - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]) + range[0];
}

// get scale domains
function notNullOrUndefined(d) {
  return d !== undefined && d !== null;
}

function unique(values) {
  const results = [];
  values.forEach(v => {
    if (!results.includes(v) && notNullOrUndefined(v)) {
      results.push(v);
    }
  });

  return results;
}

function getTruthyValues(data, valueAccessor) {
  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;
  return values.filter(notNullOrUndefined);
}

function getLinearDomain(data, valueAccessor) {
  const sorted = getTruthyValues(data, valueAccessor).sort();
  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];
}

function getQuantileDomain(data, valueAccessor) {
  return getTruthyValues(data, valueAccessor);
}

function getOrdinalDomain(data, valueAccessor) {
  return unique(getTruthyValues(data, valueAccessor));
}

function getScaleDomain(scaleType, data, valueAccessor) {
  switch (scaleType) {
    case 'quantize':
    case 'linear':
      return getLinearDomain(data, valueAccessor);

    case 'quantile':
      return getQuantileDomain(data, valueAccessor);

    case 'ordinal':
      return getOrdinalDomain(data, valueAccessor);

    default:
      return getLinearDomain(data, valueAccessor);
  }
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function getScaleFunctionByScaleType(scaleType) {
  switch (scaleType) {
    case 'quantize':
      return getQuantizeScale;
    case 'linear':
      return getLinearScale;
    case 'quantile':
      return getQuantileScale;
    case 'ordinal':
      return getOrdinalScale;

    default:
      return getQuantizeScale;
  }
}


/***/ }),

/***/ "@deck.gl/core":
/*!***********************!*\
  !*** external "deck" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__deck_gl_core__;

/***/ }),

/***/ "@luma.gl/constants":
/*!***********************!*\
  !*** external "luma" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__luma_gl_constants__;

/***/ })

/******/ });
});