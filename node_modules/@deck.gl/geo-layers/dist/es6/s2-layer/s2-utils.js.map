{"version":3,"sources":["../../../src/s2-layer/s2-utils.js"],"names":["S2","Long","getIdFromToken","token","paddedToken","padEnd","fromString","RADIAN_TO_DEGREE","Math","PI","MAX_RESOLUTION","XYZToLngLat","x","y","z","lat","atan2","sqrt","lng","getGeoBounds","face","ij","level","offsets","resolution","max","ceil","pow","result","Float64Array","ptIndex","i","offset","slice","nextOffset","stepI","stepJ","j","st","IJToST","uv","STToUV","xyz","FaceUVToXYZ","lngLat","getS2QuadKey","indexOf","S2Cell","toHilbertQuadkey","toString","getS2Polygon","key","s2cell","FromHilbertQuadKey"],"mappings":"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","sourcesContent":["// s2-geometry is a pure JavaScript port of Google/Niantic's S2 Geometry library\n// which is perfect since it works in the browser.\nimport {S2} from 's2-geometry';\nimport Long from 'long';\n\n/**\n * Given an S2 token this function convert the token to 64 bit id\n   https://github.com/google/s2-geometry-library-java/blob/c04b68bf3197a9c34082327eeb3aec7ab7c85da1/src/com/google/common/geometry/S2CellId.java#L439\n * */\nfunction getIdFromToken(token) {\n  // pad token with zeros to make the length 16\n  const paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nconst RADIAN_TO_DEGREE = 180 / Math.PI;\nconst MAX_RESOLUTION = 100;\n\n/* Adapted from s2-geometry's S2.XYZToLatLng */\nfunction XYZToLngLat([x, y, z]) {\n  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const lng = Math.atan2(y, x);\n\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\n\n/* Adapted from s2-geometry's S2Cell.getCornerLatLngs */\nfunction getGeoBounds({face, ij, level}) {\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n\n  // The S2 cell edge is curved: http://s2geometry.io/\n  // This is more prominent at lower levels\n  // resolution is the number of segments to generate per edge.\n  // We exponentially reduce resolution as level increases so it doesn't affect perf\n  // when there are a large number of cells\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      // Cell can be represented by coordinates IJ, ST, UV, XYZ\n      // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n      const st = S2.IJToST(ij, level, offset);\n      const uv = S2.STToUV(st);\n      const xyz = S2.FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n    }\n  }\n  // close the loop\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      // is Hilbert quad key\n      return token;\n    }\n    // is S2 token\n    token = getIdFromToken(token);\n  }\n  // is Long id\n  return S2.S2Cell.toHilbertQuadkey(token.toString());\n}\n\n/**\n * Get a polygon with corner coordinates for an s2 cell\n * @param {*} cell - This can be an S2 key or token\n * @return {Array} - a simple polygon in array format: [[lng, lat], ...]\n *   - each coordinate is an array [lng, lat]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\nexport function getS2Polygon(token) {\n  const key = getS2QuadKey(token);\n  const s2cell = S2.S2Cell.FromHilbertQuadKey(key);\n\n  return getGeoBounds(s2cell);\n}\n"],"file":"s2-utils.js"}