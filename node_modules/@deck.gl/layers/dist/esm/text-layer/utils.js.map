{"version":3,"sources":["../../../src/text-layer/utils.js"],"names":["log","MISSING_CHAR_WIDTH","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","i","char","width","y","height","mask","rowHeight","canvasHeight","getTextWidth","text","length","character","frameWidth","frame","warn","breakAll","maxWidth","iconMapping","rows","rowStartCharIndex","rowOffsetLeft","textWidth","push","substring","lastRowStartCharIndex","lastRowOffsetLeft","breakWord","groupStartCharIndex","group","groupWidth","lastGroupStartIndex","subGroups","concat","slice","autoWrapping","wordBreak","transformRow","lineHeight","rowOffsetTop","offsetLeft","characters","datum","offsetTop","rowWidth","transformParagraph","paragraph","transformCharacter","transformedData","autoWrappingEnabled","isFinite","size","lines","split","line","rowSize","max"],"mappings":"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","sourcesContent":["// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  let i = 0;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i++);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight,\n        mask: true\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, mapping) {\n  let width = 0;\n  for (let i = 0; i < text.length; i++) {\n    const character = text[i];\n    let frameWidth = null;\n    const frame = mapping && mapping[character];\n    if (frame) {\n      frameWidth = frame.width;\n    } else {\n      log.warn(`Missing character: ${character}`)();\n      frameWidth = MISSING_CHAR_WIDTH;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, maxWidth, iconMapping) {\n  const rows = [];\n  let rowStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text[i], iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        rows.push(text.substring(rowStartCharIndex, i));\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.substring(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n\n/* eslint-disable max-statements, complexity, max-depth */\nfunction breakWord(text, maxWidth, iconMapping) {\n  let rows = [];\n  let rowStartCharIndex = 0;\n  let groupStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n  let group = null;\n\n  for (let i = 0; i < text.length; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      group = text[i];\n      groupStartCharIndex = i + 1;\n    } else if ((i + 1 < text.length && text[i + 1] === ' ') || i + 1 === text.length) {\n      group = text.substring(groupStartCharIndex, i + 1);\n      groupStartCharIndex = i + 1;\n    } else {\n      group = null;\n    }\n\n    if (group) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(group, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        const lastGroupStartIndex = groupStartCharIndex - group.length;\n        if (rowStartCharIndex < lastGroupStartIndex) {\n          rows.push(text.substring(rowStartCharIndex, lastGroupStartIndex));\n          rowStartCharIndex = lastGroupStartIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          const subGroups = breakAll(group, maxWidth, iconMapping);\n          if (subGroups.rows.length > 1) {\n            // add all the sub rows to results except last row\n            rows = rows.concat(subGroups.rows.slice(0, subGroups.rows.length - 1));\n          }\n          // move reference to last row\n          rowStartCharIndex = rowStartCharIndex + subGroups.lastRowStartCharIndex;\n          groupWidth = subGroups.lastRowOffsetLeft;\n        }\n      }\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.substring(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n/* eslint-enable max-statements, complexity, max-depth */\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping) {\n  if (wordBreak === 'break-all') {\n    return breakAll(text, maxWidth, iconMapping);\n  }\n  return breakWord(text, maxWidth, iconMapping);\n}\n\nexport function transformRow(row, iconMapping, lineHeight, rowOffsetTop) {\n  let offsetLeft = 0;\n  let rowHeight = 0;\n\n  const characters = [];\n  for (const character of row) {\n    const datum = {\n      text: character,\n      offsetTop: rowOffsetTop,\n      offsetLeft\n    };\n\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height * lineHeight;\n      }\n      offsetLeft += frame.width;\n    } else {\n      log.warn(`Missing character: ${character}`)();\n      offsetLeft += MISSING_CHAR_WIDTH;\n    }\n\n    characters.push(datum);\n  }\n\n  return {\n    characters,\n    rowWidth: offsetLeft,\n    rowHeight\n  };\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph: {String}\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param transformCharacter {Function} callback to transform a single character\n * @param lineHeight {Number} css line-height\n * @param wordBreak {String} css word-break option\n * @param maxWidth {number} css max-width\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - offsetLeft: x offset in the row,\n *   - offsetTop: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\n// eslint-disable-next-line max-params\nexport function transformParagraph(\n  paragraph,\n  lineHeight,\n  wordBreak,\n  maxWidth,\n  iconMapping,\n  transformCharacter,\n  transformedData = []\n) {\n  if (!paragraph) {\n    return;\n  }\n\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  let rowOffsetTop = 0;\n\n  const lines = paragraph.split('\\n');\n\n  for (const line of lines) {\n    let rows = [line];\n    if (autoWrappingEnabled) {\n      rows = autoWrapping(line, wordBreak, maxWidth, iconMapping).rows;\n    }\n\n    for (const row of rows) {\n      const {rowWidth, rowHeight, characters} = transformRow(\n        row,\n        iconMapping,\n        lineHeight,\n        rowOffsetTop\n      );\n\n      const rowSize = [rowWidth, rowHeight];\n\n      for (const datum of characters) {\n        datum.size = size;\n        datum.rowSize = rowSize;\n        transformedData.push(transformCharacter(datum));\n      }\n\n      rowOffsetTop = rowOffsetTop + rowHeight;\n      size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowWidth);\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n}\n"],"file":"utils.js"}