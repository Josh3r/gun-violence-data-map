{"version":3,"sources":["../../../src/lib/layer-manager.js"],"names":["assert","Timeline","Layer","LIFECYCLE","log","debug","flatten","Stats","Viewport","createProgramManager","TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","INITIAL_CONTEXT","Object","seal","layerManager","deck","gl","stats","shaderCache","pickingFBO","mousePosition","userData","layerName","layer","LayerManager","viewport","timeline","lastRenderedLayers","layers","context","assign","programManager","id","_needsRedraw","_needsUpdate","_debug","activateViewport","bind","_finalizeLayer","opts","clearRedrawFlags","redraw","layerNeedsRedraw","getNeedsRedraw","reason","layerIds","filter","find","layerId","indexOf","props","setLayers","newLayers","forceUpdate","shouldUpdate","Boolean","_updateLayers","needsUpdate","setNeedsRedraw","oldViewport","viewportChanged","equals","changeFlags","setChangeFlags","_updateLayer","oldLayers","oldLayerMap","oldLayer","warn","generatedLayers","error","_updateSublayersRecursively","error2","_finalizeOldLayers","hasUniformTransition","firstError","newLayer","sublayers","validateProps","err","_initializeLayer","_transferLayerState","push","isComposite","getSubLayers","_initialize","lifecycle","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from '../utils/assert';\nimport {Timeline} from '@luma.gl/core';\nimport Layer from './layer';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from 'probe.gl';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\n// CONTEXT IS EXPOSED TO LAYERS\nconst INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  deck: null,\n  gl: null,\n\n  // General resources\n  stats: null, // for tracking lifecycle performance\n\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null, // Screen-size framebuffer that layers can reuse\n\n  mousePosition: null,\n\n  userData: {} // Place for any custom app `context`\n});\n\nconst layerName = layer => (layer instanceof Layer ? `${layer}` : !layer ? 'null' : 'invalid');\n\nexport default class LayerManager {\n  // eslint-disable-next-line\n  constructor(gl, {deck, stats, viewport = null, timeline = null} = {}) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.lastRenderedLayers = [];\n    this.layers = [];\n\n    this.context = Object.assign({}, INITIAL_CONTEXT, {\n      layerManager: this,\n      deck,\n      gl,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline()\n    });\n\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n\n    this.activateViewport = this.activateViewport.bind(this);\n\n    Object.seal(this);\n  }\n\n  // Method to call when the layer manager is not needed anymore.\n  finalize() {\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  // Check if a redraw is needed\n  needsRedraw(opts = {clearRedrawFlags: false}) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  // Check if a deep update of all layers is needed\n  needsUpdate() {\n    return this._needsUpdate;\n  }\n\n  // Layers will be redrawn (in next animation frame)\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  // Layers will be updated deeply (in next animation frame)\n  // Potentially regenerating attributes and sub layers\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  // Gets an (optionally) filtered list of layers\n  getLayers({layerIds = null} = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  // Set props needed for layer rendering and picking.\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // TODO - For now we set layers before viewports to preserve changeFlags\n    if ('layers' in props) {\n      this.setLayers(props.layers);\n    }\n  }\n\n  // Supply a new layer list, initiating sublayer generation and layer matching\n  setLayers(newLayers, forceUpdate = false) {\n    // TODO - something is generating state updates that cause rerender of the same\n    const shouldUpdate = forceUpdate || newLayers !== this.lastRenderedLayers;\n    debug(TRACE_SET_LAYERS, this, shouldUpdate, newLayers);\n\n    if (!shouldUpdate) {\n      return this;\n    }\n    this.lastRenderedLayers = newLayers;\n\n    newLayers = flatten(newLayers, {filter: Boolean});\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, newLayers);\n\n    return this;\n  }\n\n  // Update layers from last cycle if `setNeedsUpdate()` has been called\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      const forceUpdate = true;\n      this.setLayers(this.lastRenderedLayers, forceUpdate);\n    }\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  // Make a viewport \"current\" in layer context, updating viewportChanged flags\n  activateViewport(viewport) {\n    assert(viewport, 'LayerManager: viewport not set');\n\n    const oldViewport = this.context.viewport;\n    const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n    if (viewportChanged) {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n\n      this.context.viewport = viewport;\n      const changeFlags = {viewportChanged: true};\n\n      // Update layers states\n      // Let screen space layers update their state based on viewport\n      for (const layer of this.layers) {\n        layer.setChangeFlags(changeFlags);\n        this._updateLayer(layer);\n      }\n    }\n\n    return this;\n  }\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${layerName(oldLayer)}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    const error = this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    const error2 = this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = true;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n\n    // Throw first error found, if any\n    const firstError = error || error2;\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    let error = null;\n\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${layerName(newLayer)}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          const err = this._initializeLayer(newLayer);\n          error = error || err;\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          const err = this._updateLayer(newLayer);\n          error = error || err;\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite && newLayer.getSubLayers();\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        log.warn(`error during matching of ${layerName(newLayer)}`, err)();\n        error = error || err; // Record first exception\n      }\n\n      if (sublayers) {\n        const err = this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n        error = error || err;\n      }\n    }\n\n    return error;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    let error = null;\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        const err = this._finalizeLayer(layer);\n        error = error || err;\n      }\n    }\n    return error;\n  }\n\n  // EXCEPTION SAFE LAYER ACCESS\n\n  // Initializes a single layer, calling layer methods\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      log.warn(`error while initializing ${layerName(layer)}\\n`, err)();\n      return err;\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n\n    return null;\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  // Updates a single layer, cleaning all flags\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      log.warn(`error during update of ${layerName(layer)}`, err)();\n      // Save first error\n      return err;\n    }\n    return null;\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layerName(layer)}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      log.warn(`error during finalization of ${layerName(layer)}`, err)();\n      return err;\n    }\n    return null;\n  }\n}\n"],"file":"layer-manager.js"}