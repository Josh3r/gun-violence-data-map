{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Tesselator","constructor","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","ArrayBuffer","isView","value","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","updateGeometryAttributes","geometry","startIndex","Error","getGeometrySize","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","dataIndex","length","bufferValue","bufferStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(\n        ArrayBuffer.isView(geometryBuffer.value || geometryBuffer) && data.startIndices,\n        'invalid geometries'\n      );\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    return getAccessorFromBuffer(geometryBuffer.value || geometryBuffer, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const bufferStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = this.data.startIndices;\n      instanceCount = bufferValue.length / bufferStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}