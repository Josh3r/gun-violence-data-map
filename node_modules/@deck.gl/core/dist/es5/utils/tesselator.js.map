{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["Tesselator","opts","attributes","typedArrayManager","defaultTypedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","ArrayBuffer","isView","value","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","startRow","endRow","geometry","startIndex","Error","offset","stride","copy","name","release","def","allocate","visitor","iterable","objectInfo","object","index","Infinity","_forEachGeometry","dataIndex","getGeometrySize","length","bufferValue","bufferStride","BYTES_PER_ELEMENT","_allocate","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(\n        ArrayBuffer.isView(geometryBuffer.value || geometryBuffer) && data.startIndices,\n        'invalid geometries'\n      );\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    return getAccessorFromBuffer(geometryBuffer.value || geometryBuffer, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const bufferStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = this.data.startIndices;\n      instanceCount = bufferValue.length / bufferStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}