"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var _core = require("@luma.gl/core");

var LayersPass = function (_Pass) {
  (0, _inherits2["default"])(LayersPass, _Pass);

  function LayersPass() {
    (0, _classCallCheck2["default"])(this, LayersPass);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(LayersPass).apply(this, arguments));
  }

  (0, _createClass2["default"])(LayersPass, [{
    key: "render",
    value: function render(props) {
      var gl = this.gl;
      (0, _core.setParameters)(gl, {
        framebuffer: props.target
      });
      return this._drawLayers(props);
    }
  }, {
    key: "_drawLayers",
    value: function _drawLayers(props) {
      var _this = this;

      var viewports = props.viewports,
          views = props.views,
          onViewportActive = props.onViewportActive,
          _props$clearCanvas = props.clearCanvas,
          clearCanvas = _props$clearCanvas === void 0 ? true : _props$clearCanvas;
      var gl = this.gl;

      if (clearCanvas) {
        clearGLCanvas(gl);
      }

      var renderStats = [];
      viewports.forEach(function (viewportOrDescriptor, i) {
        var viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;
        var view = views && views[viewport.id];
        onViewportActive(viewport);
        props.viewport = viewport;
        props.view = view;

        var stats = _this._drawLayersInViewport(gl, props);

        renderStats.push(stats);
      });
      return renderStats;
    }
  }, {
    key: "_drawLayersInViewport",
    value: function _drawLayersInViewport(gl, _ref) {
      var _this2 = this;

      var layers = _ref.layers,
          layerFilter = _ref.layerFilter,
          viewport = _ref.viewport,
          view = _ref.view,
          _ref$pass = _ref.pass,
          pass = _ref$pass === void 0 ? 'unknown' : _ref$pass,
          effects = _ref.effects,
          moduleParameters = _ref.moduleParameters;
      var glViewport = getGLViewport(gl, {
        viewport: viewport
      });

      if (view && view.props.clear) {
        var clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        (0, _core.withParameters)(gl, {
          scissorTest: true,
          scissor: glViewport
        }, function () {
          return (0, _core.clear)(gl, clearOpts);
        });
      }

      var renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      (0, _core.setParameters)(gl, {
        viewport: glViewport
      });
      layers.forEach(function (layer, layerIndex) {
        var shouldDrawLayer = _this2._shouldDrawLayer(layer, viewport, pass, layerFilter);

        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }

        if (layer.isComposite) {
          renderStatus.compositeCount++;
        }

        if (shouldDrawLayer) {
          renderStatus.visibleCount++;

          var _moduleParameters = _this2._getModuleParameters(layer, effects, pass, moduleParameters);

          var uniforms = Object.assign({}, layer.context.uniforms, {
            layerIndex: layerIndex
          });

          var layerParameters = _this2.getLayerParameters(layer, layerIndex);

          layer.drawLayer({
            moduleParameters: _moduleParameters,
            uniforms: uniforms,
            parameters: layerParameters
          });
        }
      });
      return renderStatus;
    }
  }, {
    key: "shouldDrawLayer",
    value: function shouldDrawLayer(layer) {
      return true;
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects) {
      return null;
    }
  }, {
    key: "getLayerParameters",
    value: function getLayerParameters(layer, layerIndex) {
      return layer.props.parameters;
    }
  }, {
    key: "_shouldDrawLayer",
    value: function _shouldDrawLayer(layer, viewport, pass, layerFilter) {
      var shouldDrawLayer = this.shouldDrawLayer(layer) && !layer.isComposite && layer.props.visible;

      if (shouldDrawLayer && layerFilter) {
        shouldDrawLayer = layerFilter({
          layer: layer,
          viewport: viewport,
          isPicking: pass.startsWith('picking'),
          renderPass: pass
        });
      }

      return shouldDrawLayer;
    }
  }, {
    key: "_getModuleParameters",
    value: function _getModuleParameters(layer, effects, pass, overrides) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        mousePosition: layer.context.mousePosition,
        pickingActive: 0,
        devicePixelRatio: (0, _core.cssToDeviceRatio)(this.gl)
      });

      if (effects) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var effect = _step.value;
            Object.assign(moduleParameters, effect.getModuleParameters(layer));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
  }]);
  return LayersPass;
}(_pass["default"]);

exports["default"] = LayersPass;

function getGLViewport(gl, _ref2) {
  var viewport = _ref2.viewport;
  var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;
  var dimensions = viewport;
  var pixelRatio = (0, _core.cssToDeviceRatio)(gl);
  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}

function clearGLCanvas(gl) {
  var width = gl.drawingBufferWidth;
  var height = gl.drawingBufferHeight;
  (0, _core.setParameters)(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
//# sourceMappingURL=layers-pass.js.map