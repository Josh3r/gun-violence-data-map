import { Vector3, Vector4, Matrix4 } from 'math.gl';
import CullingVolume from './culling-volume';
const getPlanesRight = new Vector3();
const getPlanesNearCenter = new Vector3();
const getPlanesFarCenter = new Vector3();
const getPlanesNormal = new Vector3();
export default class PerspectiveOffCenterFrustum {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = defaultValue(options.near, 1.0);
    this._near = this.near;
    this.far = defaultValue(options.far, 500000000.0);
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
  }

  get projectionMatrix() {
    update(this);
    return this._perspectiveMatrix;
  }

  get infiniteProjectionMatrix() {
    update(this);
    return this._infinitePerspective;
  }

  computeCullingVolume(position, direction, up) {
    if (!defined(position)) {
      throw new DeveloperError('position is required.');
    }

    if (!defined(direction)) {
      throw new DeveloperError('direction is required.');
    }

    if (!defined(up)) {
      throw new DeveloperError('up is required.');
    }

    const planes = this._cullingVolume.planes;
    const t = this.top;
    const b = this.bottom;
    const r = this.right;
    const l = this.left;
    const n = this.near;
    const f = this.far;
    const right = Vector3.cross(direction, up, getPlanesRight);
    const nearCenter = getPlanesNearCenter;
    Vector3.multiplyByScalar(direction, n, nearCenter);
    Vector3.add(position, nearCenter, nearCenter);
    const farCenter = getPlanesFarCenter;
    Vector3.multiplyByScalar(direction, f, farCenter);
    Vector3.add(position, farCenter, farCenter);
    const normal = getPlanesNormal;
    Vector3.multiplyByScalar(right, l, normal);
    Vector3.add(nearCenter, normal, normal);
    Vector3.subtract(normal, position, normal);
    Vector3.normalize(normal, normal);
    Vector3.cross(normal, up, normal);
    Vector3.normalize(normal, normal);
    const plane = planes[0];

    if (!defined(plane)) {
      plane = planes[0] = new Vector4();
    }

    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Vector3.dot(normal, position);
    Vector3.multiplyByScalar(right, r, normal);
    Vector3.add(nearCenter, normal, normal);
    Vector3.subtract(normal, position, normal);
    Vector3.cross(up, normal, normal);
    Vector3.normalize(normal, normal);
    plane = planes[1];

    if (!defined(plane)) {
      plane = planes[1] = new Vector4();
    }

    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Vector3.dot(normal, position);
    Vector3.multiplyByScalar(up, b, normal);
    Vector3.add(nearCenter, normal, normal);
    Vector3.subtract(normal, position, normal);
    Vector3.cross(right, normal, normal);
    Vector3.normalize(normal, normal);
    plane = planes[2];

    if (!defined(plane)) {
      plane = planes[2] = new Vector4();
    }

    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Vector3.dot(normal, position);
    Vector3.multiplyByScalar(up, t, normal);
    Vector3.add(nearCenter, normal, normal);
    Vector3.subtract(normal, position, normal);
    Vector3.cross(normal, right, normal);
    Vector3.normalize(normal, normal);
    plane = planes[3];

    if (!defined(plane)) {
      plane = planes[3] = new Vector4();
    }

    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Vector3.dot(normal, position);
    plane = planes[4];

    if (!defined(plane)) {
      plane = planes[4] = new Vector4();
    }

    plane.x = direction.x;
    plane.y = direction.y;
    plane.z = direction.z;
    plane.w = -Vector3.dot(direction, nearCenter);
    Vector3.negate(direction, normal);
    plane = planes[5];

    if (!defined(plane)) {
      plane = planes[5] = new Vector4();
    }

    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Vector3.dot(normal, farCenter);
    return this._cullingVolume;
  }

}

function update(frustum) {
  if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
    throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
  }

  const t = frustum.top;
  const b = frustum.bottom;
  const r = frustum.right;
  const l = frustum.left;
  const n = frustum.near;
  const f = frustum.far;

  if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
    if (frustum.near <= 0 || frustum.near > frustum.far) {
      throw new DeveloperError('near must be greater than zero and less than far.');
    }

    frustum._left = l;
    frustum._right = r;
    frustum._top = t;
    frustum._bottom = b;
    frustum._near = n;
    frustum._far = f;
    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
  }
}
//# sourceMappingURL=perspective-off-center-frustum-wip.js.map