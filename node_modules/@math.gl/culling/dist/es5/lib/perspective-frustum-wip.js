"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _perspectiveOffCenterFrustumWip = _interopRequireDefault(require("./perspective-off-center-frustum-wip"));

var PerspectiveFrustum = function () {
  function PerspectiveFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PerspectiveFrustum);
    this._offCenterFrustum = new _perspectiveOffCenterFrustumWip["default"]();
    this.fov = options.fov;
    this._fov = undefined;
    this._fovy = undefined;
    this._sseDenominator = undefined;
    this.aspectRatio = options.aspectRatio;
    this._aspectRatio = undefined;
    this.near = defaultValue(options.near, 1.0);
    this._near = this.near;
    this.far = defaultValue(options.far, 500000000.0);
    this._far = this.far;
    this.xOffset = defaultValue(options.xOffset, 0.0);
    this._xOffset = this.xOffset;
    this.yOffset = defaultValue(options.yOffset, 0.0);
    this._yOffset = this.yOffset;
  }

  (0, _createClass2["default"])(PerspectiveFrustum, [{
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      update(this);
      return this._offCenterFrustum.computeCullingVolume(position, direction, up);
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._offCenterFrustum.projectionMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._offCenterFrustum.infiniteProjectionMatrix;
    }
  }, {
    key: "fovy",
    get: function get() {
      update(this);
      return this._fovy;
    }
  }, {
    key: "sseDenominator",
    get: function get() {
      update(this);
      return this._sseDenominator;
    }
  }]);
  return PerspectiveFrustum;
}();

exports["default"] = PerspectiveFrustum;

function update(frustum) {
  if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
    throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
  }

  var f = frustum._offCenterFrustum;

  if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
    if (frustum.fov < 0 || frustum.fov >= Math.PI) {
      throw new DeveloperError('fov must be in the range [0, PI).');
    }

    if (frustum.aspectRatio < 0) {
      throw new DeveloperError('aspectRatio must be positive.');
    }

    if (frustum.near < 0 || frustum.near > frustum.far) {
      throw new DeveloperError('near must be greater than zero and less than far.');
    }

    frustum._aspectRatio = frustum.aspectRatio;
    frustum._fov = frustum.fov;
    frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
    frustum._near = frustum.near;
    frustum._far = frustum.far;
    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
    frustum._xOffset = frustum.xOffset;
    frustum._yOffset = frustum.yOffset;
    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
    f.bottom = -f.top;
    f.right = frustum.aspectRatio * f.top;
    f.left = -f.right;
    f.near = frustum.near;
    f.far = frustum.far;
    f.right += frustum.xOffset;
    f.left += frustum.xOffset;
    f.top += frustum.yOffset;
    f.bottom += frustum.yOffset;
  }
}
//# sourceMappingURL=perspective-frustum-wip.js.map