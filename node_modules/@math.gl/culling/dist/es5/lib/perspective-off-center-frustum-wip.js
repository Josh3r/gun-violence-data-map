"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _readOnlyError2 = _interopRequireDefault(require("@babel/runtime/helpers/readOnlyError"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _cullingVolume = _interopRequireDefault(require("./culling-volume"));

var getPlanesRight = new _math.Vector3();
var getPlanesNearCenter = new _math.Vector3();
var getPlanesFarCenter = new _math.Vector3();
var getPlanesNormal = new _math.Vector3();

var PerspectiveOffCenterFrustum = function () {
  function PerspectiveOffCenterFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PerspectiveOffCenterFrustum);
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = defaultValue(options.near, 1.0);
    this._near = this.near;
    this.far = defaultValue(options.far, 500000000.0);
    this._far = this.far;
    this._cullingVolume = new _cullingVolume["default"]();
    this._perspectiveMatrix = new _math.Matrix4();
    this._infinitePerspective = new _math.Matrix4();
  }

  (0, _createClass2["default"])(PerspectiveOffCenterFrustum, [{
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      if (!defined(position)) {
        throw new DeveloperError('position is required.');
      }

      if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
      }

      if (!defined(up)) {
        throw new DeveloperError('up is required.');
      }

      var planes = this._cullingVolume.planes;
      var t = this.top;
      var b = this.bottom;
      var r = this.right;
      var l = this.left;
      var n = this.near;
      var f = this.far;

      var right = _math.Vector3.cross(direction, up, getPlanesRight);

      var nearCenter = getPlanesNearCenter;

      _math.Vector3.multiplyByScalar(direction, n, nearCenter);

      _math.Vector3.add(position, nearCenter, nearCenter);

      var farCenter = getPlanesFarCenter;

      _math.Vector3.multiplyByScalar(direction, f, farCenter);

      _math.Vector3.add(position, farCenter, farCenter);

      var normal = getPlanesNormal;

      _math.Vector3.multiplyByScalar(right, l, normal);

      _math.Vector3.add(nearCenter, normal, normal);

      _math.Vector3.subtract(normal, position, normal);

      _math.Vector3.normalize(normal, normal);

      _math.Vector3.cross(normal, up, normal);

      _math.Vector3.normalize(normal, normal);

      var plane = planes[0];

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[0] = new _math.Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -_math.Vector3.dot(normal, position);

      _math.Vector3.multiplyByScalar(right, r, normal);

      _math.Vector3.add(nearCenter, normal, normal);

      _math.Vector3.subtract(normal, position, normal);

      _math.Vector3.cross(up, normal, normal);

      _math.Vector3.normalize(normal, normal);

      plane = ((0, _readOnlyError2["default"])("plane"), planes[1]);

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[1] = new _math.Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -_math.Vector3.dot(normal, position);

      _math.Vector3.multiplyByScalar(up, b, normal);

      _math.Vector3.add(nearCenter, normal, normal);

      _math.Vector3.subtract(normal, position, normal);

      _math.Vector3.cross(right, normal, normal);

      _math.Vector3.normalize(normal, normal);

      plane = ((0, _readOnlyError2["default"])("plane"), planes[2]);

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[2] = new _math.Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -_math.Vector3.dot(normal, position);

      _math.Vector3.multiplyByScalar(up, t, normal);

      _math.Vector3.add(nearCenter, normal, normal);

      _math.Vector3.subtract(normal, position, normal);

      _math.Vector3.cross(normal, right, normal);

      _math.Vector3.normalize(normal, normal);

      plane = ((0, _readOnlyError2["default"])("plane"), planes[3]);

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[3] = new _math.Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -_math.Vector3.dot(normal, position);
      plane = ((0, _readOnlyError2["default"])("plane"), planes[4]);

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[4] = new _math.Vector4());
      }

      plane.x = direction.x;
      plane.y = direction.y;
      plane.z = direction.z;
      plane.w = -_math.Vector3.dot(direction, nearCenter);

      _math.Vector3.negate(direction, normal);

      plane = ((0, _readOnlyError2["default"])("plane"), planes[5]);

      if (!defined(plane)) {
        plane = ((0, _readOnlyError2["default"])("plane"), planes[5] = new _math.Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -_math.Vector3.dot(normal, farCenter);
      return this._cullingVolume;
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._perspectiveMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._infinitePerspective;
    }
  }]);
  return PerspectiveOffCenterFrustum;
}();

exports["default"] = PerspectiveOffCenterFrustum;

function update(frustum) {
  if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
    throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
  }

  var t = frustum.top;
  var b = frustum.bottom;
  var r = frustum.right;
  var l = frustum.left;
  var n = frustum.near;
  var f = frustum.far;

  if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
    if (frustum.near <= 0 || frustum.near > frustum.far) {
      throw new DeveloperError('near must be greater than zero and less than far.');
    }

    frustum._left = l;
    frustum._right = r;
    frustum._top = t;
    frustum._bottom = b;
    frustum._near = n;
    frustum._far = f;
    frustum._perspectiveMatrix = _math.Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
    frustum._infinitePerspective = _math.Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
  }
}
//# sourceMappingURL=perspective-off-center-frustum-wip.js.map