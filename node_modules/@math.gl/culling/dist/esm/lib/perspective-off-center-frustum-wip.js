import _readOnlyError from "@babel/runtime/helpers/esm/readOnlyError";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { Vector3, Vector4, Matrix4 } from 'math.gl';
import CullingVolume from './culling-volume';
var getPlanesRight = new Vector3();
var getPlanesNearCenter = new Vector3();
var getPlanesFarCenter = new Vector3();
var getPlanesNormal = new Vector3();

var PerspectiveOffCenterFrustum = function () {
  function PerspectiveOffCenterFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PerspectiveOffCenterFrustum);

    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = defaultValue(options.near, 1.0);
    this._near = this.near;
    this.far = defaultValue(options.far, 500000000.0);
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
  }

  _createClass(PerspectiveOffCenterFrustum, [{
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      if (!defined(position)) {
        throw new DeveloperError('position is required.');
      }

      if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
      }

      if (!defined(up)) {
        throw new DeveloperError('up is required.');
      }

      var planes = this._cullingVolume.planes;
      var t = this.top;
      var b = this.bottom;
      var r = this.right;
      var l = this.left;
      var n = this.near;
      var f = this.far;
      var right = Vector3.cross(direction, up, getPlanesRight);
      var nearCenter = getPlanesNearCenter;
      Vector3.multiplyByScalar(direction, n, nearCenter);
      Vector3.add(position, nearCenter, nearCenter);
      var farCenter = getPlanesFarCenter;
      Vector3.multiplyByScalar(direction, f, farCenter);
      Vector3.add(position, farCenter, farCenter);
      var normal = getPlanesNormal;
      Vector3.multiplyByScalar(right, l, normal);
      Vector3.add(nearCenter, normal, normal);
      Vector3.subtract(normal, position, normal);
      Vector3.normalize(normal, normal);
      Vector3.cross(normal, up, normal);
      Vector3.normalize(normal, normal);
      var plane = planes[0];

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[0] = new Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -Vector3.dot(normal, position);
      Vector3.multiplyByScalar(right, r, normal);
      Vector3.add(nearCenter, normal, normal);
      Vector3.subtract(normal, position, normal);
      Vector3.cross(up, normal, normal);
      Vector3.normalize(normal, normal);
      plane = (_readOnlyError("plane"), planes[1]);

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[1] = new Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -Vector3.dot(normal, position);
      Vector3.multiplyByScalar(up, b, normal);
      Vector3.add(nearCenter, normal, normal);
      Vector3.subtract(normal, position, normal);
      Vector3.cross(right, normal, normal);
      Vector3.normalize(normal, normal);
      plane = (_readOnlyError("plane"), planes[2]);

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[2] = new Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -Vector3.dot(normal, position);
      Vector3.multiplyByScalar(up, t, normal);
      Vector3.add(nearCenter, normal, normal);
      Vector3.subtract(normal, position, normal);
      Vector3.cross(normal, right, normal);
      Vector3.normalize(normal, normal);
      plane = (_readOnlyError("plane"), planes[3]);

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[3] = new Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -Vector3.dot(normal, position);
      plane = (_readOnlyError("plane"), planes[4]);

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[4] = new Vector4());
      }

      plane.x = direction.x;
      plane.y = direction.y;
      plane.z = direction.z;
      plane.w = -Vector3.dot(direction, nearCenter);
      Vector3.negate(direction, normal);
      plane = (_readOnlyError("plane"), planes[5]);

      if (!defined(plane)) {
        plane = (_readOnlyError("plane"), planes[5] = new Vector4());
      }

      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -Vector3.dot(normal, farCenter);
      return this._cullingVolume;
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._perspectiveMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._infinitePerspective;
    }
  }]);

  return PerspectiveOffCenterFrustum;
}();

export { PerspectiveOffCenterFrustum as default };

function update(frustum) {
  if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
    throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
  }

  var t = frustum.top;
  var b = frustum.bottom;
  var r = frustum.right;
  var l = frustum.left;
  var n = frustum.near;
  var f = frustum.far;

  if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
    if (frustum.near <= 0 || frustum.near > frustum.far) {
      throw new DeveloperError('near must be greater than zero and less than far.');
    }

    frustum._left = l;
    frustum._right = r;
    frustum._top = t;
    frustum._bottom = b;
    frustum._near = n;
    frustum._far = f;
    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
  }
}
//# sourceMappingURL=perspective-off-center-frustum-wip.js.map