{"version":3,"sources":["../../../../src/lib/tileset/tile-3d-header.js"],"names":["Vector3","Matrix4","CullingVolume","Intersect","parse","fetchFile","path","Tile3DLoader","Tileset3DLoader","TILE3D_REFINEMENT","TILE3D_CONTENT_STATE","TILE3D_OPTIMIZATION_HINT","assert","createBoundingVolume","defined","x","undefined","scratchVector","Tile3DHeader","constructor","tileset","header","parentHeader","basePath","_tileset","_header","_basePath","_content","_contentState","UNLOADED","_gpuMemoryUsageInBytes","parent","children","refine","_getRefine","cacheNode","userData","geometricError","console","warn","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeCache","_optimChildrenWithinParent","NOT_COMPUTED","_initializeRenderingState","Object","seal","destroy","isDestroyed","gpuMemoryUsageInBytes","depth","_depth","selectedFrame","_selectedFrame","isVisibleAndInRequestVolume","_visible","_inRequestVolume","content","contentReady","READY","hasRenderContent","hasEmptyContent","hasTilesetContent","contentAvailable","_expiredContent","contentFailed","hasUnloadedContent","contentUnloaded","contentExpired","EXPIRED","FAILED","url","getTileUrl","contentUri","uri","boundingVolume","_boundingVolume","contentBoundingVolume","_contentBoundingVolume","boundingSphere","extras","hasChildren","length","getScreenSpaceError","frameState","useParentGeometricError","parentGeometricError","distance","Math","max","_distanceToCamera","height","sseDenominator","error","_getDynamicScreenSpaceError","fog","distanceToCamera","density","scalar","exp","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","loadContent","expired","expireDate","LOADING","updatePriority","tile","_priority","cancelled","_requestScheduler","scheduleRequest","response","startRequest","options","fetchOptions","endRequest","indexOf","_initializeTileHeaders","dirname","_contentLoaded","unloadContent","updateVisibility","_updatedVisibilityFrame","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","MASK_INDETERMINATE","_updateTransform","distanceToTile","_screenSpaceError","visibility","MASK_OUTSIDE","insideViewerRequestVolume","updateExpiration","now","Date","lessThan","cullingVolume","clippingPlanes","clippingPlanesOriginMatrix","enabled","intersection","computeIntersectionWithBoundingVolume","_isClipped","INSIDE","OUTSIDE","computeVisibilityWithPlaneMask","contentVisibility","sqrt","distanceSquaredTo","camera","position","cameraSpaceZDepth","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","expire","expireDuration","duration","date","fromIso8601","tileHeader","transform","clone","multiplyRight","parentInitialTransform","_initialTransform","_tile","contentState","_serverKey","fullUri","id","_centerZDepth","_finalResolution","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","REPLACE","ADD","_isTileset","Boolean","asset","type","traverser","disableSkipLevelOfDetail","didTransformChange","equals"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {CullingVolume, Intersect} from '@math.gl/culling';\nimport {parse, fetchFile, path} from '@loaders.gl/core';\nimport Tile3DLoader from '../../tile-3d-loader';\nimport Tileset3DLoader from '../../tileset-3d-loader';\nimport {TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport assert from '../utils/assert';\nimport {createBoundingVolume} from './helpers/bounding-volume';\n\nconst defined = x => x !== undefined && x !== null;\n\nconst scratchVector = new Vector3();\n\n// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class Tile3DHeader {\n  constructor(tileset, header, parentHeader, basePath) {\n    // assert(tileset._asset);\n    assert(typeof header === 'object');\n\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    // The tile's children.\n    this.children = [];\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;\n      // eslint-disable-next-line\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeCache(header);\n\n    // Marks whether the tile's children bounds are fully contained within the tile's bounds\n    // @type {TILE3D_OPTIMIZATION_HINT}\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this._header = null;\n  }\n\n  isDestroyed() {\n    return this._header === null;\n  }\n\n  // The tileset containing this tile.\n  get gpuMemoryUsageInBytes() {\n    return this._gpuMemoryUsageInBytes;\n  }\n\n  // The tileset containing this tile.\n  get tileset() {\n    return this._tileset;\n  }\n\n  // The depth of the tile in the tileset tree.\n  get depth() {\n    return this._depth;\n  }\n\n  // The most recent frame that the tile was selected\n  get selectedFrame() {\n    return this._selectedFrame;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // The tile's content.  This represents the actual tile's payload,\n  // not the content's metadata in the tileset JSON file.\n  get content() {\n    return this._content;\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this._contentState === TILE3D_CONTENT_STATE.READY;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return (\n      (this.contentReady && this.hasRenderContent) ||\n      (defined(this._expiredContent) && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n  }\n\n  get url() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  get uri() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  // Get the tile's bounding volume.\n  get boundingVolume() {\n    return this._boundingVolume;\n  }\n\n  // Get the bounding volume of the tile's contents.  This defaults to the\n  // tile's bounding volume when the content's bounding volume is `undefined`.\n  get contentBoundingVolume() {\n    return this._contentBoundingVolume || this._boundingVolume;\n  }\n\n  // Get the bounding sphere derived from the tile's bounding volume.\n  get boundingSphere() {\n    return this._boundingVolume.boundingSphere;\n  }\n\n  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.\n  // Returns `undefined` if `extras` does not exist.\n  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n  get extras() {\n    return this._header.extras;\n  }\n\n  get hasChildren() {\n    // this.children are Tile3DHeader objects with content fetched from server\n    // this._header.children are children of this tile which are not yet fetched\n    return this.children.length > 0 || (this._header.children && this.children.length > 0);\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentGeometricError) {\n    const tileset = this._tileset;\n    const parentGeometricError =\n      (this.parent && this.parent.geometricError) || tileset.geometricError;\n    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n    // Leaf tiles do not have any error so save the computation\n    if (geometricError === 0.0) {\n      return 0.0;\n    }\n\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, 1e-7);\n    const {height, sseDenominator} = frameState;\n    let error = (geometricError * height) / (distance * sseDenominator);\n\n    error -= this._getDynamicScreenSpaceError(distance);\n\n    return error;\n  }\n\n  // TODO: Refined screen space error that minimizes tiles in non-first-person\n  _getDynamicScreenSpaceError(distance) {\n    function fog(distanceToCamera, density) {\n      const scalar = distanceToCamera * density;\n      return 1.0 - Math.exp(-(scalar * scalar));\n    }\n\n    const tileset = this._tileset;\n\n    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = fog(distance, density) * factor;\n      return dynamicError;\n    }\n\n    return 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  // eslint-disable-next-line max-statements\n  async loadContent(frameState) {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this._content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    // Append a query parameter of the tile expiration date to prevent caching\n    // if (expired) {\n    //   expired: this.expireDate.toString()\n    // const request = new Request({\n    //   throttle: true,\n    //   throttleByServer: true,\n    //   type: RequestType.TILES3D,\n    //   priorityFunction: createPriorityFunction(this),\n    //   serverKey: this._serverKey\n    // });\n\n    if (expired) {\n      this.expireDate = undefined;\n    }\n\n    this._contentState = TILE3D_CONTENT_STATE.LOADING;\n\n    function updatePriority(tile) {\n      // Check if any reason to abort\n      if (!tile._visible) {\n        return -1;\n      }\n      if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - tile._priority, 0) || 0;\n    }\n\n    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));\n\n    if (cancelled) {\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUri = this.uri;\n\n      let response;\n      try {\n        this.tileset._requestScheduler.startRequest(this);\n        response = await fetchFile(contentUri, this.tileset.options.fetchOptions);\n      } finally {\n        this.tileset._requestScheduler.endRequest(this);\n      }\n\n      // The content can be a binary tile ot a JSON tileset\n      this._content = await parse(response, [Tile3DLoader, Tileset3DLoader]);\n      // if (Tile3D.isTile(content)) {\n      //   new Tileset3D(content, contentUri);\n\n      if (contentUri.indexOf('.json') !== -1) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n      }\n\n      this._contentState = TILE3D_CONTENT_STATE.READY;\n      this._contentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this._contentState = TILE3D_CONTENT_STATE.FAILED;\n      throw error;\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (!this.hasRenderContent) {\n      return false;\n    }\n    if (this._content && this._content.destroy) {\n      this._content.destroy();\n    }\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // _getOrthograhicScreenSpaceError() {\n  // if (frustum instanceof OrthographicFrustum) {\n  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  //   error = geometricError / pixelSize;\n  // }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    const tileset = this._tileset;\n    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    // this._centerZDepth = this.cameraSpaceZDepth(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n  }\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      if (Date.lessThan(this.expireDate, now)) {\n        this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this._content;\n      }\n    }\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume, tileset} = this;\n\n    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    if (clippingPlanes && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      }\n    }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this._contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile._contentBoundingVolume;\n\n    const tileset = this._tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this._boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n  }\n\n  // PRIVATE\n\n  _initializeCache(header) {\n    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n    this.cacheNode = undefined;\n\n    const expire = header.expire;\n    let expireDuration;\n    let expireDate;\n    if (expire) {\n      expireDuration = expire.duration;\n      if (expire.date) {\n        expireDate = Date.fromIso8601(expire.date);\n      }\n    }\n\n    // The time in seconds after the tile's content is ready when the content expires and new content is requested.\n    // @type {Number}\n    this.expireDuration = expireDuration;\n\n    // The date when the content expires and new content is requested.\n    // @type {Date}\n    this.expireDate = expireDate;\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this._tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (tileHeader.content && tileHeader.content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        tileHeader.boundingVolume,\n        this.computedTransform\n      );\n    }\n\n    if (tileHeader.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        tileHeader.viewerRequestVolume,\n        this.computedTransform\n      );\n    }\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this._content = {_tileset: this._tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._expiredContent = undefined;\n    this._serverKey = null;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    // If a content tileHeader\n    if (tileHeader.content) {\n      this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n      if ('url' in tileHeader) {\n        // eslint-disable-next-line\n        console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n        this.contentUri = tileHeader.url;\n      }\n      this._content = null;\n      this.hasEmptyContent = false;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this.fullUri = `${this._basePath}/${this.contentUri}`;\n      this.id = this.fullUri;\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState() {\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._finalResolution = true;\n    this._depth = 0;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._updatedVisibilityFrame = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._ancestorWithContent = undefined;\n    this._ancestorWithContentAvailable = undefined;\n    this._refines = false;\n    this._shouldSelect = false;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    switch (refine) {\n      case 'REPLACE':\n      case 'replace':\n        return TILE3D_REFINEMENT.REPLACE;\n      case 'ADD':\n      case 'add':\n        return TILE3D_REFINEMENT.ADD;\n      default:\n        // Inherit from parent tile if omitted.\n        return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n    }\n  }\n\n  _isTileset(content) {\n    return Boolean(content.asset);\n  }\n\n  _contentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this._content && this._content.type) {\n      case 'vctr':\n      case 'geom':\n        this.tileset.traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset(this._content)) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    // Matrix4.clone(computedTransform, this.computedTransform);\n\n    // Update the bounding volumes\n    const header = this._header;\n\n    const content = this._header.content;\n    this._boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this._boundingVolume\n    );\n    if (this._contentBoundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (this._viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n}\n\n/*\nfunction updateContent(tile, tileset, frameState) {\n  const content = tile._content;\n  const expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    const expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function() {\n    return tile._priority;\n  };\n}\n*/\n"],"file":"tile-3d-header.js"}