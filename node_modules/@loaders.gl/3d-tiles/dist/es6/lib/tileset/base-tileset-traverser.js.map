{"version":3,"sources":["../../../../src/lib/tileset/base-tileset-traverser.js"],"names":["ManagedArray","TILE3D_REFINEMENT","assert","DEFAULT_OPTIONS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","BaseTilesetTraverser","constructor","options","_traversalStack","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","traverse","frameState","reset","updateTile","canTraverse","frameNumber","executeTraversal","stack","push","length","tile","pop","refines","updateChildTiles","updateAndPushChildren","parent","parentRefines","Boolean","_refines","stoppedRefining","hasRenderContent","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","onTraverseEnd","children","child","sort","compareDistanceToCamera","checkRefines","hasVisibleChild","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","updateExpiration","shouldSelectTile","_selectedFrame","fullUri","shouldLoadTile","_requestedFrame","_priority","getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","shouldRefine","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","updateVisibility","b","a","_distanceToCamera","useParentScreenSpaceError","rootScreenSpaceError","anyChildrenVisible","anyVisible","allDescendantsLoaded","filter","c"],"mappings":"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","sourcesContent":["import ManagedArray from '../utils/managed-array';\nimport {TILE3D_REFINEMENT} from '../constants';\nimport assert from '../utils/assert';\n\nexport const DEFAULT_OPTIONS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2\n};\n\nexport default class BaseTilesetTraverser {\n  // TODO nested props\n  constructor(options) {\n    this.options = {...DEFAULT_OPTIONS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    // check if traversable\n    if (!this.canTraverse(root, frameState, true)) {\n      return false;\n    }\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n\n    return true;\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let refines = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        refines = this.updateAndPushChildren(tile, frameState, stack);\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._refines);\n      const stoppedRefining = !refines;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE3D_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE3D_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._refines = refines && parentRefines;\n    }\n\n    if (this.options.onTraverseEnd) {\n      this.options.onTraverseEnd();\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  // eslint-disable-next-line complexity\n  updateAndPushChildren(tile, frameState, stack) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera);\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      !skipLevelOfDetail && tile.refine === TILE3D_REFINEMENT.REPLACE && tile.hasRenderContent;\n\n    let refines = true;\n\n    let hasVisibleChild = false;\n    for (const child of children) {\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n\n    return refines;\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n    tile.updateExpiration();\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile, frameState)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.fullUri] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile, frameState)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = this.getPriority(tile);\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile, frameState) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile, frameState) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    tile.updateVisibility(frameState);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n  // Additive tiles are prioritized by distance because it subjectively looks better.\n  // Replacement tiles are prioritized by screen space error.\n  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance\n  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.\n  // TODO move to tile-3d-header\n  getPriority(tile) {\n    const {options} = this;\n    switch (tile.refine) {\n      case TILE3D_REFINEMENT.ADD:\n        return tile._distanceToCamera;\n\n      case TILE3D_REFINEMENT.REPLACE:\n        const {parent} = tile;\n        const useParentScreenSpaceError =\n          parent &&\n          (!options.skipLevelOfDetail ||\n            tile._screenSpaceError === 0.0 ||\n            parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n          ? parent._screenSpaceError\n          : tile._screenSpaceError;\n        const rootScreenSpaceError = this.root._screenSpaceError;\n        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)\n\n      default:\n        return assert(false);\n    }\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // TODO revisit this empty traversal logic\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n        this.touchTile(tile, frameState);\n      }\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      // Traversal stops but the tile does not have content yet.\n      // There will be holes if the parent tries to refine to its children, so don't refine.\n      if (!traverse && !tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n\n      if (traverse) {\n        const children = tile.children.filter(c => c);\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"],"file":"base-tileset-traverser.js"}