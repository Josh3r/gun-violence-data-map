{"version":3,"sources":["../../../../src/lib/tileset/tile-3d-header.js"],"names":["defined","x","undefined","scratchVector","Vector3","Tile3DHeader","tileset","header","parentHeader","basePath","_tileset","_header","_basePath","_content","_contentState","TILE3D_CONTENT_STATE","UNLOADED","_gpuMemoryUsageInBytes","parent","children","refine","_getRefine","cacheNode","userData","geometricError","console","warn","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeCache","_optimChildrenWithinParent","TILE3D_OPTIMIZATION_HINT","NOT_COMPUTED","_initializeRenderingState","Object","seal","frameState","useParentGeometricError","parentGeometricError","distance","Math","max","_distanceToCamera","height","sseDenominator","error","_getDynamicScreenSpaceError","fog","distanceToCamera","density","scalar","exp","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","updatePriority","tile","_visible","_priority","hasEmptyContent","expired","contentExpired","expireDate","LOADING","_requestScheduler","scheduleRequest","cancelled","contentUri","uri","startRequest","options","fetchOptions","response","endRequest","Tile3DLoader","Tileset3DLoader","indexOf","_initializeTileHeaders","path","dirname","READY","_contentLoaded","FAILED","hasRenderContent","destroy","_updatedVisibilityFrame","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","CullingVolume","MASK_INDETERMINATE","_updateTransform","distanceToTile","_screenSpaceError","getScreenSpaceError","visibility","MASK_OUTSIDE","_inRequestVolume","insideViewerRequestVolume","contentReady","now","Date","lessThan","EXPIRED","_expiredContent","cullingVolume","boundingVolume","clippingPlanes","clippingPlanesOriginMatrix","enabled","intersection","computeIntersectionWithBoundingVolume","_isClipped","Intersect","INSIDE","OUTSIDE","computeVisibilityWithPlaneMask","_boundingVolume","sqrt","distanceSquaredTo","camera","position","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","expire","expireDuration","duration","date","fromIso8601","tileHeader","transform","Matrix4","clone","multiplyRight","parentInitialTransform","_initialTransform","_contentBoundingVolume","content","_tile","contentState","_serverKey","hasTilesetContent","url","fullUri","id","_centerZDepth","_finalResolution","_depth","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_selectedFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","TILE3D_REFINEMENT","REPLACE","ADD","Boolean","asset","type","traverser","disableSkipLevelOfDetail","_isTileset","didTransformChange","equals","contentFailed","contentUnloaded","getTileUrl","boundingSphere","extras","length"],"mappings":";;;;;;;;;;;;;;;;;;;AAGA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA,IAAMA,OAAO,GAAG,SAAVA,OAAU,CAAAC,CAAC;AAAA,SAAIA,CAAC,KAAKC,SAAN,IAAmBD,CAAC,KAAK,IAA7B;AAAA,CAAjB;;AAEA,IAAME,aAAa,GAAG,IAAIC,aAAJ,EAAtB;;IAKqBC,Y;AACnB,wBAAYC,OAAZ,EAAqBC,MAArB,EAA6BC,YAA7B,EAA2CC,QAA3C,EAAqD;AAAA;AAEnD,4BAAO,yBAAOF,MAAP,MAAkB,QAAzB;AAEA,SAAKG,QAAL,GAAgBJ,OAAhB;AACA,SAAKK,OAAL,GAAeJ,MAAf;AACA,SAAKK,SAAL,GAAiBH,QAAjB;AACA,SAAKI,QAAL,GAAgB,IAAhB;AACA,SAAKC,aAAL,GAAqBC,gCAAqBC,QAA1C;AACA,SAAKC,sBAAL,GAA8B,CAA9B;AAGA,SAAKC,MAAL,GAAcV,YAAd;AAEA,SAAKW,QAAL,GAAgB,EAAhB;AAEA,SAAKC,MAAL,GAAc,KAAKC,UAAL,CAAgBd,MAAM,CAACa,MAAvB,CAAd;AACA,SAAKE,SAAL,GAAiBpB,SAAjB;AACA,SAAKqB,QAAL,GAAgB,EAAhB;;AAIA,QAAI,oBAAoBhB,MAAxB,EAAgC;AAC9B,WAAKiB,cAAL,GAAsBjB,MAAM,CAACiB,cAA7B;AACD,KAFD,MAEO;AACL,WAAKA,cAAL,GAAuB,KAAKN,MAAL,IAAe,KAAKA,MAAL,CAAYM,cAA5B,IAA+ClB,OAAO,CAACkB,cAA7E;AAEAC,MAAAA,OAAO,CAACC,IAAR,CAAa,wEAAb;AACD;;AAED,SAAKC,qBAAL,CAA2BpB,MAA3B;;AACA,SAAKqB,0BAAL,CAAgCrB,MAAhC;;AACA,SAAKsB,kBAAL,CAAwBtB,MAAxB;;AACA,SAAKuB,gBAAL,CAAsBvB,MAAtB;;AAIA,SAAKwB,0BAAL,GAAkCC,oCAAyBC,YAA3D;;AAEA,SAAKC,yBAAL;;AAEAC,IAAAA,MAAM,CAACC,IAAP,CAAY,IAAZ;AACD;;;;8BAES;AACR,WAAKzB,OAAL,GAAe,IAAf;AACD;;;kCAEa;AACZ,aAAO,KAAKA,OAAL,KAAiB,IAAxB;AACD;;;wCAiHmB0B,U,EAAYC,uB,EAAyB;AACvD,UAAMhC,OAAO,GAAG,KAAKI,QAArB;AACA,UAAM6B,oBAAoB,GACvB,KAAKrB,MAAL,IAAe,KAAKA,MAAL,CAAYM,cAA5B,IAA+ClB,OAAO,CAACkB,cADzD;AAEA,UAAMA,cAAc,GAAGc,uBAAuB,GAAGC,oBAAH,GAA0B,KAAKf,cAA7E;;AAGA,UAAIA,cAAc,KAAK,GAAvB,EAA4B;AAC1B,eAAO,GAAP;AACD;;AAMD,UAAMgB,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKC,iBAAd,EAAiC,IAAjC,CAAjB;AAfuD,UAgBhDC,MAhBgD,GAgBtBP,UAhBsB,CAgBhDO,MAhBgD;AAAA,UAgBxCC,cAhBwC,GAgBtBR,UAhBsB,CAgBxCQ,cAhBwC;AAiBvD,UAAIC,KAAK,GAAItB,cAAc,GAAGoB,MAAlB,IAA6BJ,QAAQ,GAAGK,cAAxC,CAAZ;AAEAC,MAAAA,KAAK,IAAI,KAAKC,2BAAL,CAAiCP,QAAjC,CAAT;AAEA,aAAOM,KAAP;AACD;;;gDAG2BN,Q,EAAU;AACpC,eAASQ,GAAT,CAAaC,gBAAb,EAA+BC,OAA/B,EAAwC;AACtC,YAAMC,MAAM,GAAGF,gBAAgB,GAAGC,OAAlC;AACA,eAAO,MAAMT,IAAI,CAACW,GAAL,CAAS,EAAED,MAAM,GAAGA,MAAX,CAAT,CAAb;AACD;;AAED,UAAM7C,OAAO,GAAG,KAAKI,QAArB;;AAEA,UAAIJ,OAAO,CAAC+C,uBAAR,IAAmC/C,OAAO,CAACgD,uCAA/C,EAAwF;AACtF,YAAMJ,OAAO,GAAG5C,OAAO,CAACgD,uCAAxB;AACA,YAAMC,MAAM,GAAGjD,OAAO,CAACkD,6BAAvB;AACA,YAAMC,YAAY,GAAGT,GAAG,CAACR,QAAD,EAAWU,OAAX,CAAH,GAAyBK,MAA9C;AACA,eAAOE,YAAP;AACD;;AAED,aAAO,CAAP;AACD;;;;0GAKiBpB,U;qBA4BPqB,c;;;;;AAAAA,gBAAAA,c,iBAAeC,I,EAAM;AAE5B,sBAAI,CAACA,IAAI,CAACC,QAAV,EAAoB;AAClB,2BAAO,CAAC,CAAR;AACD;;AACD,sBAAID,IAAI,CAAC7C,aAAL,KAAuBC,gCAAqBC,QAAhD,EAA0D;AACxD,2BAAO,CAAC,CAAR;AACD;;AACD,yBAAOyB,IAAI,CAACC,GAAL,CAAS,MAAMiB,IAAI,CAACE,SAApB,EAA+B,CAA/B,KAAqC,CAA5C;AACD,iB;;qBApCG,KAAKC,e;;;;;iDACA,K;;;qBAGL,KAAKjD,Q;;;;;iDACA,I;;;AAGHkD,gBAAAA,O,GAAU,KAAKC,c;;AAarB,oBAAID,OAAJ,EAAa;AACX,uBAAKE,UAAL,GAAkB/D,SAAlB;AACD;;AAED,qBAAKY,aAAL,GAAqBC,gCAAqBmD,OAA1C;;uBAa0B,KAAK5D,OAAL,CAAa6D,iBAAb,CAA+BC,eAA/B,CAA+C,IAA/C,EAAqDV,cAArD,C;;;AAApBW,gBAAAA,S;;qBAEFA,S;;;;;AACF,qBAAKvD,aAAL,GAAqBC,gCAAqBC,QAA1C;iDACO,K;;;;AAIDsD,gBAAAA,U,GAAa,KAAKC,G;;;AAItB,qBAAKjE,OAAL,CAAa6D,iBAAb,CAA+BK,YAA/B,CAA4C,IAA5C;;;uBACiB,qBAAUF,UAAV,EAAsB,KAAKhE,OAAL,CAAamE,OAAb,CAAqBC,YAA3C,C;;;AAAjBC,gBAAAA,Q;;;;;AAEA,qBAAKrE,OAAL,CAAa6D,iBAAb,CAA+BS,UAA/B,CAA0C,IAA1C;;;;;;uBAIoB,iBAAMD,QAAN,EAAgB,CAACE,wBAAD,EAAeC,2BAAf,CAAhB,C;;;AAAtB,qBAAKjE,Q;;AAIL,oBAAIyD,UAAU,CAACS,OAAX,CAAmB,OAAnB,MAAgC,CAAC,CAArC,EAAwC;AAItC,uBAAKrE,QAAL,CAAcsE,sBAAd,CAAqC,KAAKnE,QAA1C,EAAoD,IAApD,EAA0DoE,WAAKC,OAAL,CAAa,KAAKX,GAAlB,CAA1D;AACD;;AAED,qBAAKzD,aAAL,GAAqBC,gCAAqBoE,KAA1C;;AACA,qBAAKC,cAAL;;iDACO,I;;;;;AAGP,qBAAKtE,aAAL,GAAqBC,gCAAqBsE,MAA1C;;;;;;;;;;;;;;;;;;;oCAMY;AACd,UAAI,CAAC,KAAKC,gBAAV,EAA4B;AAC1B,eAAO,KAAP;AACD;;AACD,UAAI,KAAKzE,QAAL,IAAiB,KAAKA,QAAL,CAAc0E,OAAnC,EAA4C;AAC1C,aAAK1E,QAAL,CAAc0E,OAAd;AACD;;AACD,WAAK1E,QAAL,GAAgB,IAAhB;AACA,WAAKC,aAAL,GAAqBC,gCAAqBC,QAA1C;AACA,aAAO,IAAP;AACD;;;qCASgBqB,U,EAAY;AAC3B,UAAM/B,OAAO,GAAG,KAAKI,QAArB;;AACA,UAAI,KAAK8E,uBAAL,KAAiClF,OAAO,CAACkF,uBAA7C,EAAsE;AAGpE;AACD;;AAED,UAAMtE,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMuE,eAAe,GAAGvE,MAAM,GAAGA,MAAM,CAACwE,iBAAV,GAA8B,KAAKhF,QAAL,CAAciF,WAA1E;AACA,UAAMC,yBAAyB,GAAG1E,MAAM,GACpCA,MAAM,CAAC2E,oBAD6B,GAEpCC,uBAAcC,kBAFlB;;AAGA,WAAKC,gBAAL,CAAsBP,eAAtB;;AACA,WAAK9C,iBAAL,GAAyB,KAAKsD,cAAL,CAAoB5D,UAApB,CAAzB;AAEA,WAAK6D,iBAAL,GAAyB,KAAKC,mBAAL,CAAyB9D,UAAzB,EAAqC,KAArC,CAAzB;AACA,WAAKwD,oBAAL,GAA4B,KAAKO,UAAL,CAAgB/D,UAAhB,EAA4BuD,yBAA5B,CAA5B;AACA,WAAKhC,QAAL,GAAgB,KAAKiC,oBAAL,KAA8BC,uBAAcO,YAA5D;AACA,WAAKC,gBAAL,GAAwB,KAAKC,yBAAL,CAA+BlE,UAA/B,CAAxB;AAEA,WAAKmD,uBAAL,GAA+BlF,OAAO,CAACkF,uBAAvC;AACD;;;uCAGkB;AACjB,UAAIxF,OAAO,CAAC,KAAKiE,UAAN,CAAP,IAA4B,KAAKuC,YAAjC,IAAiD,CAAC,KAAK1C,eAA3D,EAA4E;AAC1E,YAAM2C,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;AACA,YAAIC,IAAI,CAACC,QAAL,CAAc,KAAK1C,UAAnB,EAA+BwC,GAA/B,CAAJ,EAAyC;AACvC,eAAK3F,aAAL,GAAqBC,gCAAqB6F,OAA1C;AACA,eAAKC,eAAL,GAAuB,KAAKhG,QAA5B;AACD;AACF;AACF;;;+BAMUwB,U,EAAYuD,yB,EAA2B;AAAA,UACzCkB,aADyC,GACxBzE,UADwB,CACzCyE,aADyC;AAAA,UAEzCC,cAFyC,GAEd,IAFc,CAEzCA,cAFyC;AAAA,UAEzBzG,OAFyB,GAEd,IAFc,CAEzBA,OAFyB;AAAA,UAIzC0G,cAJyC,GAIK1G,OAJL,CAIzC0G,cAJyC;AAAA,UAIzBC,0BAJyB,GAIK3G,OAJL,CAIzB2G,0BAJyB;;AAKhD,UAAID,cAAc,IAAIA,cAAc,CAACE,OAArC,EAA8C;AAC5C,YAAMC,YAAY,GAAGH,cAAc,CAACI,qCAAf,CACnBL,cADmB,EAEnBE,0BAFmB,CAArB;AAIA,aAAKI,UAAL,GAAkBF,YAAY,KAAKG,mBAAUC,MAA7C;;AACA,YAAIJ,YAAY,KAAKG,mBAAUE,OAA/B,EAAwC;AACtC,iBAAO1B,uBAAcO,YAArB;AACD;AACF;;AAGD,aAAOS,aAAa,CAACW,8BAAd,CAA6CV,cAA7C,EAA6DnB,yBAA7D,CAAP;AACD;;;sCAMiBvD,U,EAAY;AAC5B,aAAO,IAAP;AAkCD;;;mCAKcA,U,EAAY;AACzB,UAAM0E,cAAc,GAAG,KAAKW,eAA5B;AACA,aAAOjF,IAAI,CAACkF,IAAL,CAAUlF,IAAI,CAACC,GAAL,CAASqE,cAAc,CAACa,iBAAf,CAAiCvF,UAAU,CAACwF,MAAX,CAAkBC,QAAnD,CAAT,EAAuE,CAAvE,CAAV,CAAP;AACD;;;6CAK2B;AAAA,UAATD,MAAS,SAATA,MAAS;AAC1B,UAAMd,cAAc,GAAG,KAAKA,cAA5B;AACA5G,MAAAA,aAAa,CAAC4H,UAAd,CAAyBhB,cAAc,CAACiB,MAAxC,EAAgDH,MAAM,CAACC,QAAvD;AACA,aAAOD,MAAM,CAACI,SAAP,CAAiBC,GAAjB,CAAqB/H,aAArB,CAAP;AACD;;;8CAOyBkC,U,EAAY;AACpC,UAAM8F,mBAAmB,GAAG,KAAKC,oBAAjC;AACA,aAAO,CAACD,mBAAD,IAAwBA,mBAAmB,CAAClF,gBAApB,CAAqCZ,UAArC,MAAqD,GAApF;AACD;;;qCAIgB9B,M,EAAQ;AAEvB,WAAKe,SAAL,GAAiBpB,SAAjB;AAEA,UAAMmI,MAAM,GAAG9H,MAAM,CAAC8H,MAAtB;AACA,UAAIC,cAAJ;AACA,UAAIrE,UAAJ;;AACA,UAAIoE,MAAJ,EAAY;AACVC,QAAAA,cAAc,GAAGD,MAAM,CAACE,QAAxB;;AACA,YAAIF,MAAM,CAACG,IAAX,EAAiB;AACfvE,UAAAA,UAAU,GAAGyC,IAAI,CAAC+B,WAAL,CAAiBJ,MAAM,CAACG,IAAxB,CAAb;AACD;AACF;;AAID,WAAKF,cAAL,GAAsBA,cAAtB;AAIA,WAAKrE,UAAL,GAAkBA,UAAlB;AACD;;;0CAEqByE,U,EAAY;AAEhC,WAAKC,SAAL,GAAiBD,UAAU,CAACC,SAAX,GAAuB,IAAIC,aAAJ,CAAYF,UAAU,CAACC,SAAvB,CAAvB,GAA2D,IAAIC,aAAJ,EAA5E;AAEA,UAAM1H,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMZ,OAAO,GAAG,KAAKI,QAArB;AAEA,UAAM+E,eAAe,GACnBvE,MAAM,IAAIA,MAAM,CAACwE,iBAAjB,GACIxE,MAAM,CAACwE,iBAAP,CAAyBmD,KAAzB,EADJ,GAEIvI,OAAO,CAACqF,WAAR,CAAoBkD,KAApB,EAHN;AAIA,WAAKnD,iBAAL,GAAyB,IAAIkD,aAAJ,CAAYnD,eAAZ,EAA6BqD,aAA7B,CAA2C,KAAKH,SAAhD,CAAzB;AAEA,UAAMI,sBAAsB,GAC1B7H,MAAM,IAAIA,MAAM,CAAC8H,iBAAjB,GAAqC9H,MAAM,CAAC8H,iBAAP,CAAyBH,KAAzB,EAArC,GAAwE,IAAID,aAAJ,EAD1E;AAEA,WAAKI,iBAAL,GAAyB,IAAIJ,aAAJ,CAAYG,sBAAZ,EAAoCD,aAApC,CAAkD,KAAKH,SAAvD,CAAzB;AACD;;;+CAE0BD,U,EAAY;AACrC,WAAKhB,eAAL,GAAuB,0CAAqBgB,UAAU,CAAC3B,cAAhC,EAAgD,KAAKrB,iBAArD,CAAvB;AAEA,WAAKuD,sBAAL,GAA8B,IAA9B;AACA,WAAKb,oBAAL,GAA4B,IAA5B;;AAOA,UAAIM,UAAU,CAACQ,OAAX,IAAsBR,UAAU,CAACQ,OAAX,CAAmBnC,cAA7C,EAA6D;AAC3D,aAAKkC,sBAAL,GAA8B,0CAC5BP,UAAU,CAAC3B,cADiB,EAE5B,KAAKrB,iBAFuB,CAA9B;AAID;;AAED,UAAIgD,UAAU,CAACP,mBAAf,EAAoC;AAClC,aAAKC,oBAAL,GAA4B,0CAC1BM,UAAU,CAACP,mBADe,EAE1B,KAAKzC,iBAFqB,CAA5B;AAID;AACF;;;uCAEkBgD,U,EAAY;AAE7B,WAAK7H,QAAL,GAAgB;AAACH,QAAAA,QAAQ,EAAE,KAAKA,QAAhB;AAA0ByI,QAAAA,KAAK,EAAE;AAAjC,OAAhB;AACA,WAAKrF,eAAL,GAAuB,IAAvB;AACA,WAAKsF,YAAL,GAAoBrI,gCAAqBC,QAAzC;AACA,WAAK6F,eAAL,GAAuB3G,SAAvB;AACA,WAAKmJ,UAAL,GAAkB,IAAlB;AAIA,WAAKC,iBAAL,GAAyB,KAAzB;;AAGA,UAAIZ,UAAU,CAACQ,OAAf,EAAwB;AACtB,aAAK5E,UAAL,GAAkBoE,UAAU,CAACQ,OAAX,CAAmB3E,GAAnB,IAA0BmE,UAAU,CAACQ,OAAX,CAAmBK,GAA/D;;AACA,YAAI,SAASb,UAAb,EAAyB;AAEvBjH,UAAAA,OAAO,CAACC,IAAR,CAAa,2EAAb;AACA,eAAK4C,UAAL,GAAkBoE,UAAU,CAACa,GAA7B;AACD;;AACD,aAAK1I,QAAL,GAAgB,IAAhB;AACA,aAAKiD,eAAL,GAAuB,KAAvB;AACA,aAAKsF,YAAL,GAAoBrI,gCAAqBC,QAAzC;AACA,aAAKwI,OAAL,aAAkB,KAAK5I,SAAvB,cAAoC,KAAK0D,UAAzC;AACA,aAAKmF,EAAL,GAAU,KAAKD,OAAf;AACD;AACF;;;gDAG2B;AAE1B,WAAK7G,iBAAL,GAAyB,CAAzB;AACA,WAAK+G,aAAL,GAAqB,CAArB;AACA,WAAKxD,iBAAL,GAAyB,CAAzB;AACA,WAAKL,oBAAL,GAA4BC,uBAAcC,kBAA1C;AACA,WAAKnC,QAAL,GAAgB,KAAhB;AACA,WAAK0C,gBAAL,GAAwB,KAAxB;AAEA,WAAKqD,gBAAL,GAAwB,IAAxB;AACA,WAAKC,MAAL,GAAc,CAAd;AACA,WAAKC,YAAL,GAAoB,CAApB;AACA,WAAKC,eAAL,GAAuB,CAAvB;AAEA,WAAKtE,uBAAL,GAA+B,CAA/B;AACA,WAAKuE,aAAL,GAAqB,CAArB;AACA,WAAKC,aAAL,GAAqB,CAArB;AACA,WAAKC,cAAL,GAAsB,CAAtB;AACA,WAAKC,eAAL,GAAuB,CAAvB;AACA,WAAKC,oBAAL,GAA4BjK,SAA5B;AACA,WAAKkK,6BAAL,GAAqClK,SAArC;AACA,WAAKmK,QAAL,GAAgB,KAAhB;AACA,WAAKC,aAAL,GAAqB,KAArB;AACA,WAAKzG,SAAL,GAAiB,GAAjB;AACD;;;+BAEUzC,M,EAAQ;AACjB,cAAQA,MAAR;AACE,aAAK,SAAL;AACA,aAAK,SAAL;AACE,iBAAOmJ,6BAAkBC,OAAzB;;AACF,aAAK,KAAL;AACA,aAAK,KAAL;AACE,iBAAOD,6BAAkBE,GAAzB;;AACF;AAEE,iBAAO,KAAKvJ,MAAL,GAAc,KAAKA,MAAL,CAAYE,MAA1B,GAAmCmJ,6BAAkBC,OAA5D;AATJ;AAWD;;;+BAEUtB,O,EAAS;AAClB,aAAOwB,OAAO,CAACxB,OAAO,CAACyB,KAAT,CAAd;AACD;;;qCAEgB;AAEf,cAAQ,KAAK9J,QAAL,IAAiB,KAAKA,QAAL,CAAc+J,IAAvC;AACE,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKtK,OAAL,CAAauK,SAAb,CAAuBC,wBAAvB,GAAkD,IAAlD;AACA;;AACF;AALF;;AASA,UAAI,KAAKC,UAAL,CAAgB,KAAKlK,QAArB,CAAJ,EAAoC;AAClC,aAAKyI,iBAAL,GAAyB,IAAzB;AACD;AACF;;;uCAGiD;AAAA,UAAjC7D,eAAiC,uEAAf,IAAImD,aAAJ,EAAe;AAChD,UAAMlD,iBAAiB,GAAGD,eAAe,CAACoD,KAAhB,GAAwBC,aAAxB,CAAsC,KAAKH,SAA3C,CAA1B;AACA,UAAMqC,kBAAkB,GAAG,CAACtF,iBAAiB,CAACuF,MAAlB,CAAyB,KAAKvF,iBAA9B,CAA5B;;AAEA,UAAI,CAACsF,kBAAL,EAAyB;AACvB;AACD;;AAED,WAAKtF,iBAAL,GAAyBA,iBAAzB;AAKA,UAAMnF,MAAM,GAAG,KAAKI,OAApB;AAEA,UAAMuI,OAAO,GAAG,KAAKvI,OAAL,CAAauI,OAA7B;AACA,WAAKxB,eAAL,GAAuB,0CACrBnH,MAAM,CAACwG,cADc,EAErB,KAAKrB,iBAFgB,EAGrB,KAAKgC,eAHgB,CAAvB;;AAKA,UAAI,KAAKuB,sBAAT,EAAiC;AAC/B,aAAKA,sBAAL,GAA8B,0CAC5BC,OAAO,CAACnC,cADoB,EAE5B,KAAKrB,iBAFuB,EAG5B,KAAKuD,sBAHuB,CAA9B;AAKD;;AACD,UAAI,KAAKb,oBAAT,EAA+B;AAC7B,aAAKA,oBAAL,GAA4B,0CAC1B7H,MAAM,CAAC4H,mBADmB,EAE1B,KAAKzC,iBAFqB,EAG1B,KAAK0C,oBAHqB,CAA5B;AAKD;AACF;;;wBAhkB2B;AAC1B,aAAO,KAAKnH,sBAAZ;AACD;;;wBAGa;AACZ,aAAO,KAAKP,QAAZ;AACD;;;wBAGW;AACV,aAAO,KAAKkJ,MAAZ;AACD;;;wBAGmB;AAClB,aAAO,KAAKK,cAAZ;AACD;;;wBAEiC;AAChC,aAAO,KAAKrG,QAAL,IAAiB,KAAK0C,gBAA7B;AACD;;;wBAIa;AACZ,aAAO,KAAKzF,QAAZ;AACD;;;wBAIkB;AACjB,aAAO,KAAKC,aAAL,KAAuBC,gCAAqBoE,KAAnD;AACD;;;wBAGsB;AACrB,aAAO,CAAC,KAAKrB,eAAN,IAAyB,CAAC,KAAKwF,iBAAtC;AACD;;;wBAIsB;AACrB,aACG,KAAK9C,YAAL,IAAqB,KAAKlB,gBAA3B,IACCtF,OAAO,CAAC,KAAK6G,eAAN,CAAP,IAAiC,CAAC,KAAKqE,aAF1C;AAID;;;wBAGwB;AACvB,aAAO,KAAK5F,gBAAL,IAAyB,KAAK6F,eAArC;AACD;;;wBAIqB;AACpB,aAAO,KAAKrK,aAAL,KAAuBC,gCAAqBC,QAAnD;AACD;;;wBAIoB;AACnB,aAAO,KAAKF,aAAL,KAAuBC,gCAAqB6F,OAAnD;AACD;;;wBAImB;AAClB,aAAO,KAAK9F,aAAL,KAAuBC,gCAAqBsE,MAAnD;AACD;;;wBAES;AACR,aAAO,KAAK/E,OAAL,CAAa8K,UAAb,CAAwB,KAAK9G,UAA7B,EAAyC,KAAK1D,SAA9C,CAAP;AACD;;;wBAES;AACR,aAAO,KAAKN,OAAL,CAAa8K,UAAb,CAAwB,KAAK9G,UAA7B,EAAyC,KAAK1D,SAA9C,CAAP;AACD;;;wBAGoB;AACnB,aAAO,KAAK8G,eAAZ;AACD;;;wBAI2B;AAC1B,aAAO,KAAKuB,sBAAL,IAA+B,KAAKvB,eAA3C;AACD;;;wBAGoB;AACnB,aAAO,KAAKA,eAAL,CAAqB2D,cAA5B;AACD;;;wBAKY;AACX,aAAO,KAAK1K,OAAL,CAAa2K,MAApB;AACD;;;wBAEiB;AAGhB,aAAO,KAAKnK,QAAL,CAAcoK,MAAd,GAAuB,CAAvB,IAA6B,KAAK5K,OAAL,CAAaQ,QAAb,IAAyB,KAAKA,QAAL,CAAcoK,MAAd,GAAuB,CAApF;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {CullingVolume, Intersect} from '@math.gl/culling';\nimport {parse, fetchFile, path} from '@loaders.gl/core';\nimport Tile3DLoader from '../../tile-3d-loader';\nimport Tileset3DLoader from '../../tileset-3d-loader';\nimport {TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport assert from '../utils/assert';\nimport {createBoundingVolume} from './helpers/bounding-volume';\n\nconst defined = x => x !== undefined && x !== null;\n\nconst scratchVector = new Vector3();\n\n// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class Tile3DHeader {\n  constructor(tileset, header, parentHeader, basePath) {\n    // assert(tileset._asset);\n    assert(typeof header === 'object');\n\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    // The tile's children.\n    this.children = [];\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;\n      // eslint-disable-next-line\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeCache(header);\n\n    // Marks whether the tile's children bounds are fully contained within the tile's bounds\n    // @type {TILE3D_OPTIMIZATION_HINT}\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this._header = null;\n  }\n\n  isDestroyed() {\n    return this._header === null;\n  }\n\n  // The tileset containing this tile.\n  get gpuMemoryUsageInBytes() {\n    return this._gpuMemoryUsageInBytes;\n  }\n\n  // The tileset containing this tile.\n  get tileset() {\n    return this._tileset;\n  }\n\n  // The depth of the tile in the tileset tree.\n  get depth() {\n    return this._depth;\n  }\n\n  // The most recent frame that the tile was selected\n  get selectedFrame() {\n    return this._selectedFrame;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // The tile's content.  This represents the actual tile's payload,\n  // not the content's metadata in the tileset JSON file.\n  get content() {\n    return this._content;\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this._contentState === TILE3D_CONTENT_STATE.READY;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return (\n      (this.contentReady && this.hasRenderContent) ||\n      (defined(this._expiredContent) && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n  }\n\n  get url() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  get uri() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  // Get the tile's bounding volume.\n  get boundingVolume() {\n    return this._boundingVolume;\n  }\n\n  // Get the bounding volume of the tile's contents.  This defaults to the\n  // tile's bounding volume when the content's bounding volume is `undefined`.\n  get contentBoundingVolume() {\n    return this._contentBoundingVolume || this._boundingVolume;\n  }\n\n  // Get the bounding sphere derived from the tile's bounding volume.\n  get boundingSphere() {\n    return this._boundingVolume.boundingSphere;\n  }\n\n  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.\n  // Returns `undefined` if `extras` does not exist.\n  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n  get extras() {\n    return this._header.extras;\n  }\n\n  get hasChildren() {\n    // this.children are Tile3DHeader objects with content fetched from server\n    // this._header.children are children of this tile which are not yet fetched\n    return this.children.length > 0 || (this._header.children && this.children.length > 0);\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentGeometricError) {\n    const tileset = this._tileset;\n    const parentGeometricError =\n      (this.parent && this.parent.geometricError) || tileset.geometricError;\n    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n    // Leaf tiles do not have any error so save the computation\n    if (geometricError === 0.0) {\n      return 0.0;\n    }\n\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, 1e-7);\n    const {height, sseDenominator} = frameState;\n    let error = (geometricError * height) / (distance * sseDenominator);\n\n    error -= this._getDynamicScreenSpaceError(distance);\n\n    return error;\n  }\n\n  // TODO: Refined screen space error that minimizes tiles in non-first-person\n  _getDynamicScreenSpaceError(distance) {\n    function fog(distanceToCamera, density) {\n      const scalar = distanceToCamera * density;\n      return 1.0 - Math.exp(-(scalar * scalar));\n    }\n\n    const tileset = this._tileset;\n\n    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = fog(distance, density) * factor;\n      return dynamicError;\n    }\n\n    return 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  // eslint-disable-next-line max-statements\n  async loadContent(frameState) {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this._content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    // Append a query parameter of the tile expiration date to prevent caching\n    // if (expired) {\n    //   expired: this.expireDate.toString()\n    // const request = new Request({\n    //   throttle: true,\n    //   throttleByServer: true,\n    //   type: RequestType.TILES3D,\n    //   priorityFunction: createPriorityFunction(this),\n    //   serverKey: this._serverKey\n    // });\n\n    if (expired) {\n      this.expireDate = undefined;\n    }\n\n    this._contentState = TILE3D_CONTENT_STATE.LOADING;\n\n    function updatePriority(tile) {\n      // Check if any reason to abort\n      if (!tile._visible) {\n        return -1;\n      }\n      if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - tile._priority, 0) || 0;\n    }\n\n    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));\n\n    if (cancelled) {\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUri = this.uri;\n\n      let response;\n      try {\n        this.tileset._requestScheduler.startRequest(this);\n        response = await fetchFile(contentUri, this.tileset.options.fetchOptions);\n      } finally {\n        this.tileset._requestScheduler.endRequest(this);\n      }\n\n      // The content can be a binary tile ot a JSON tileset\n      this._content = await parse(response, [Tile3DLoader, Tileset3DLoader]);\n      // if (Tile3D.isTile(content)) {\n      //   new Tileset3D(content, contentUri);\n\n      if (contentUri.indexOf('.json') !== -1) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n      }\n\n      this._contentState = TILE3D_CONTENT_STATE.READY;\n      this._contentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this._contentState = TILE3D_CONTENT_STATE.FAILED;\n      throw error;\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (!this.hasRenderContent) {\n      return false;\n    }\n    if (this._content && this._content.destroy) {\n      this._content.destroy();\n    }\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // _getOrthograhicScreenSpaceError() {\n  // if (frustum instanceof OrthographicFrustum) {\n  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  //   error = geometricError / pixelSize;\n  // }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    const tileset = this._tileset;\n    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    // this._centerZDepth = this.cameraSpaceZDepth(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n  }\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      if (Date.lessThan(this.expireDate, now)) {\n        this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this._content;\n      }\n    }\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume, tileset} = this;\n\n    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    if (clippingPlanes && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      }\n    }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this._contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile._contentBoundingVolume;\n\n    const tileset = this._tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this._boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n  }\n\n  // PRIVATE\n\n  _initializeCache(header) {\n    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n    this.cacheNode = undefined;\n\n    const expire = header.expire;\n    let expireDuration;\n    let expireDate;\n    if (expire) {\n      expireDuration = expire.duration;\n      if (expire.date) {\n        expireDate = Date.fromIso8601(expire.date);\n      }\n    }\n\n    // The time in seconds after the tile's content is ready when the content expires and new content is requested.\n    // @type {Number}\n    this.expireDuration = expireDuration;\n\n    // The date when the content expires and new content is requested.\n    // @type {Date}\n    this.expireDate = expireDate;\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this._tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (tileHeader.content && tileHeader.content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        tileHeader.boundingVolume,\n        this.computedTransform\n      );\n    }\n\n    if (tileHeader.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        tileHeader.viewerRequestVolume,\n        this.computedTransform\n      );\n    }\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this._content = {_tileset: this._tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._expiredContent = undefined;\n    this._serverKey = null;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    // If a content tileHeader\n    if (tileHeader.content) {\n      this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n      if ('url' in tileHeader) {\n        // eslint-disable-next-line\n        console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n        this.contentUri = tileHeader.url;\n      }\n      this._content = null;\n      this.hasEmptyContent = false;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this.fullUri = `${this._basePath}/${this.contentUri}`;\n      this.id = this.fullUri;\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState() {\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._finalResolution = true;\n    this._depth = 0;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._updatedVisibilityFrame = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._ancestorWithContent = undefined;\n    this._ancestorWithContentAvailable = undefined;\n    this._refines = false;\n    this._shouldSelect = false;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    switch (refine) {\n      case 'REPLACE':\n      case 'replace':\n        return TILE3D_REFINEMENT.REPLACE;\n      case 'ADD':\n      case 'add':\n        return TILE3D_REFINEMENT.ADD;\n      default:\n        // Inherit from parent tile if omitted.\n        return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n    }\n  }\n\n  _isTileset(content) {\n    return Boolean(content.asset);\n  }\n\n  _contentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this._content && this._content.type) {\n      case 'vctr':\n      case 'geom':\n        this.tileset.traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset(this._content)) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    // Matrix4.clone(computedTransform, this.computedTransform);\n\n    // Update the bounding volumes\n    const header = this._header;\n\n    const content = this._header.content;\n    this._boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this._boundingVolume\n    );\n    if (this._contentBoundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (this._viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n}\n\n/*\nfunction updateContent(tile, tileset, frameState) {\n  const content = tile._content;\n  const expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    const expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function() {\n    return tile._priority;\n  };\n}\n*/\n"],"file":"tile-3d-header.js"}