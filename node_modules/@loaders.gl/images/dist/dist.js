(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../loader-utils/src/categories/mesh/mesh-utils.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/categories/mesh/mesh-utils.js ***!
  \*********************************************************/
/*! exports provided: getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}


/***/ }),

/***/ "../loader-utils/src/index.js":
/*!************************************!*\
  !*** ../loader-utils/src/index.js ***!
  \************************************/
/*! exports provided: createWorker, assert, isBrowser, isWorker, nodeVersion, self, window, global, document, getLibraryUrl, loadLibrary, getTransferList, validateLoaderVersion, parseJSON, padTo4Bytes, copyToArray, copyArrayBuffer, getZeroOffsetArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, getFirstCharacters, getMagicString, setPathPrefix, getPathPrefix, resolvePath, _addAliases, _getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_create_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/create-worker */ "../loader-utils/src/lib/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _lib_create_worker__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["isWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["nodeVersion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["document"]; });

/* harmony import */ var _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/library-utils/library-utils */ "../loader-utils/src/lib/library-utils/library-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_3__["getLibraryUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_3__["loadLibrary"]; });

/* harmony import */ var _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_4__["getTransferList"]; });

/* harmony import */ var _lib_validate_loader_version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/validate-loader-version */ "../loader-utils/src/lib/validate-loader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return _lib_validate_loader_version__WEBPACK_IMPORTED_MODULE_5__["validateLoaderVersion"]; });

/* harmony import */ var _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/parser-utils/parse-json */ "../loader-utils/src/lib/parser-utils/parse-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_6__["parseJSON"]; });

/* harmony import */ var _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/binary-utils/memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_7__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_7__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_7__["copyArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_7__["getZeroOffsetArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/binary-utils/binary-copy-utils */ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_8__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_8__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/binary-utils/encode-utils */ "../loader-utils/src/lib/binary-utils/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_9__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_9__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_9__["copyBinaryToDataView"]; });

/* harmony import */ var _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_10__["getFirstCharacters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_10__["getMagicString"]; });

/* harmony import */ var _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/path-utils/file-aliases */ "../loader-utils/src/lib/path-utils/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_11__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_11__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_11__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_addAliases", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_11__["addAliases"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../loader-utils/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_12__["getMeshSize"]; });



// GENERAL UTILS



// LIBRARY UTILS


// WORKER UTILS



// PARSER UTILS


// MEMORY COPY UTILS





// PATH UTILS


// FOR TESTING ONLY, EXPERIMENTAL


// MESH CATEGORY UTILS
// Note: Should move to category specific module if code size increases



/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/binary-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* global TextEncoder */


function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(sourceBuffer.byteLength);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    // Copy array
    const targetArray = new Uint8Array(
      dataView.buffer,
      dataView.byteOffset + byteOffset,
      sourceBuffer.byteLength
    );
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    // Add PADDING
    for (let i = 0; i < padLength; ++i) {
      // json chunk is padded with spaces (ASCII 0x20)
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  // PERFORMANCE IDEA: We encode twice, once to get size and once to store
  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy
  const stringBuffer = textEncoder.encode(string);

  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);

  return byteOffset;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/encode-utils.js":
/*!************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/encode-utils.js ***!
  \************************************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
// UTILITIES

// PERFORMANCE IDEA: No need to copy string twice...
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }
  return byteOffset + byteLength;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/get-first-characters.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/get-first-characters.js ***!
  \********************************************************************/
/*! exports provided: getFirstCharacters, getMagicString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return getFirstCharacters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return getMagicString; });
function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    // Typed Arrays can have offsets into underlying buffer
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/memory-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: padTo4Bytes, getZeroOffsetArrayBuffer, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return getZeroOffsetArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0
function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength
    ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)
    : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|TypedArray} source - The data to copy
 * @param {TypedArray} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}


/***/ }),

/***/ "../loader-utils/src/lib/create-worker.js":
/*!************************************************!*\
  !*** ../loader-utils/src/lib/create-worker.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony import */ var _validate_loader_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validate-loader-version */ "../loader-utils/src/lib/validate-loader-version.js");
/* eslint-disable no-restricted-globals */
/* global TextDecoder, self */



// Set up a WebWorkerGlobalScope to talk with the main thread
function createWorker(loader) {
  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?
  if (typeof self === 'undefined') {
    return;
  }

  let requestId = 0;
  const parse = (arraybuffer, options = {}, url) =>
    new Promise((resolve, reject) => {
      const id = requestId++;

      const onMessage = ({data}) => {
        if (!data || data.id !== id) {
          // not ours
          return;
        }
        switch (data.type) {
          case 'parse-done':
            self.removeEventListener('message', onMessage);
            resolve(data.result);
            break;

          case 'parse-error':
            self.removeEventListener('message', onMessage);
            reject(data.message);
            break;

          default:
          // ignore
        }
      };
      self.addEventListener('message', onMessage);
      // Ask the main thread to decode data
      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);
    });

  self.onmessage = async evt => {
    const {data} = evt;

    try {
      if (!isKnownMessage(data, loader.name)) {
        return;
      }

      Object(_validate_loader_version__WEBPACK_IMPORTED_MODULE_1__["validateLoaderVersion"])(loader, data.source.split('@')[1]);

      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;

      const result = await parseData({
        loader,
        arraybuffer,
        byteOffset,
        byteLength,
        options,
        context: {parse}
      });
      const transferList = Object(_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(result);
      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      self.postMessage({type: 'error', message: error.message});
    }
  };
}

// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)
// TODO - Why not support async loader.parse* funcs here?
// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?
// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse
async function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arraybuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arraybuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error(`Could not load data with ${loader.name} loader`);
  }

  // TODO - proper merge in of loader options...
  options = {
    ...options,
    modules: (loader && loader.options && loader.options.modules) || {},
    worker: false
  };

  return await parser(data, {...options}, context, loader);
}

// Filter out noise messages sent to workers
function isKnownMessage(data, name) {
  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');
}

/*
function checkMessage(evt, name) {
  switch (evt.data && evt.data.source) {
    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...
    case 'react-devtools-bridge':
    case 'react-devtools-content-script':
    case 'react-devtools-detector':
      return false;
    default:
      // fall through
  }

  switch (evt.data && evt.data.type) {
    case 'webpackProgress':
    case 'webpackOk':
      return false;
    default:
      // Enable to debug messages
      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;
      // console.log(message, evt.data, evt); // eslint-disable-line
      return false;
  }
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/assert.js":
/*!***************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/assert.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/globals.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/globals.js ***!
  \****************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, window, global, document, self, importScripts */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const isWorker = typeof importScripts === 'function';

// Extract node major version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/lib/library-utils/library-utils.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/library-utils/library-utils.js ***!
  \**************************************************************/
/*! exports provided: loadLibrary, getLibraryUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return loadLibrary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return getLibraryUrl; });
/* harmony import */ var _env_utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony import */ var _require_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./require-utils.node */ 0);
/* harmony import */ var _require_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_require_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
// __VERSION__ is injected by babel-plugin-version-inline
/* global __VERSION__ */
/* global fetch, document */




// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
const LATEST = 'beta';
const VERSION =  true ? "2.0.0" : undefined;

const loadLibraryPromises = {}; // promises

// Dynamically loads a library ("module")
// wasm library: Array buffer is returned
// js library: Parse JS is returned
//  browser - script element is created and installed on document
//  worker - eval is called on global context
//  node - file is required
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }

  // Ensure libraries are only loaded once
  loadLibraryPromises[libraryUrl] =
    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}

// TODO - sort out how to resolve paths for main/worker and dev/prod
function getLibraryUrl(library, moduleName, options) {
  // Allow application to import and supply libraries through `options.modules`
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }

  // Load from local files, not from CDN scripts in Node.js
  // TODO - needs to locate the modules directory when installed!
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return `modules/${moduleName}/dist/libs/${library}`;
  }

  // In browser, load from external scripts
  if (options.CDN) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(options.CDN.startsWith('http'));
    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;
  }

  // TODO - loading inside workers requires paths relative to worker script location...
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    return `../src/libs/${library}`;
  }

  return `modules/${moduleName}/src/libs/${library}`;
}

async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }

  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return Object(_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"])(libraryUrl);
  }
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    /* global importScripts */
    return importScripts(libraryUrl);
  }
  // TODO - fix - should be more secure than string parsing since observes CORS
  // if (isBrowser) {
  //   return await loadScriptFromFile(libraryUrl);
  // }

  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}

/*
async function loadScriptFromFile(libraryUrl) {
  const script = document.createElement('script');
  script.src = libraryUrl;
  return await new Promise((resolve, reject) => {
    script.onload = data => {
      resolve(data);
    };
    script.onerror = reject;
  });
}
*/

// TODO - Needs security audit...
//  - Raw eval call
//  - Potentially bypasses CORS
// Upside is that this separates fetching and parsing
// we could create a`LibraryLoader` or`ModuleLoader`
function loadLibraryFromString(scriptSource, id) {
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return Object(_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"])(scriptSource, id);
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    // Use lvalue trick to make eval run in global scope
    eval.call(_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"], scriptSource); // eslint-disable-line no-eval
    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript
    // http://perfectionkills.com/global-eval-what-are-the-options/
    return null;
  }

  const script = document.createElement('script');
  script.id = id;
  // most browsers like a separate text node but some throw an error. The second method covers those.
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}

// TODO - technique for module injection into worker, from THREE.DracoLoader...
/*
function combineWorkerWithLibrary(worker, jsContent) {
  var fn = wWorker.toString();
  var body = [
    '// injected',
    jsContent,
    '',
    '// worker',
    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
  ].join('\n');
  this.workerSourceURL = URL.createObjectURL(new Blob([body]));
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/parser-utils/parse-json.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/parser-utils/parse-json.js ***!
  \**********************************************************/
/*! exports provided: parseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return parseJSON; });
/* harmony import */ var _binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");


// Minimal JSON parser with a meaningful error message
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${Object(_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__["getFirstCharacters"])(string)}"`);
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/path-utils/file-aliases.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/path-utils/file-aliases.js ***!
  \**********************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are an experimental export,
// they are only for testing of loaders.gl loaders
// not inteded as a generic aliasing mechanism
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }
  filename += pathPrefix;
  return filename;
}


/***/ }),

/***/ "../loader-utils/src/lib/validate-loader-version.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/validate-loader-version.js ***!
  \**********************************************************/
/*! exports provided: validateLoaderVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return validateLoaderVersion; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
// __VERSION__ is injected by babel-plugin-version-inline
/* global __VERSION__ */


const VERSION =  true ? "2.0.0" : undefined;

// Returns `true` if the two versions are compatible
function validateLoaderVersion(loader, coreVersion = VERSION) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader, 'no loader provided');

  let loaderVersion = loader.version;
  if (!coreVersion || !loaderVersion) {
    return;
  }

  coreVersion = parseVersion(coreVersion);
  loaderVersion = parseVersion(loaderVersion);

  // TODO enable when fix the __version__ injection
  // assert(
  //   coreVersion.major === loaderVersion.major && coreVersion.minor <= loaderVersion.minor,
  //   `loader: ${loader.name} is not compatible. ${coreVersion.major}.${
  //     coreVersion.minor
  //   }+ is required.`
  // );
}

function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {major: parts[0], minor: parts[1]};
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/get-transfer-list.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/get-transfer-list.js ***!
  \*****************************************************************/
/*! exports provided: getTransferList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
// NOTE - there is a copy of this function is both in core and loader-utils
// core does not need all the utils in loader-utils, just this one.

/* global MessagePort, ImageBitmap, OffscreenCanvas */

// Returns an array of Transferrable objects that can be used with postMessage
// https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (isTransferable(object)) {
    transfers.add(object);
  } else if (isTransferable(object.buffer)) {
    // Typed array
    transfers.add(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : null;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Transferable
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== `undefined` && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== `undefined` && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");

const _global = typeof window === 'undefined' ? global : window;
_global.loaders = _global.loaders || {};

module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/image-loader.js":
/*!*****************************!*\
  !*** ./src/image-loader.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parsers/parse-image */ "./src/lib/parsers/parse-image.js");
/* harmony import */ var _lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/binary-image-api/binary-image-parsers */ "./src/lib/binary-image-api/binary-image-parsers.js");
/* global __VERSION__ */ // __VERSION__ is injected by babel-plugin-version-inline



const VERSION =  true ? "2.0.0" : undefined;

const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
const MIME_TYPES = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'image/webp',
  'image/bmp',
  'image/vndmicrosofticon',
  'image/svg+xml'
];

// Loads a platform-specific image type that can be used as input data to WebGL textures
const ImageLoader = {
  name: 'Images',
  version: VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  test: arrayBuffer => {
    const dataView = new DataView(arrayBuffer); // , byteOffset, byteLength);
    return Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_1__["isJpeg"])(dataView) || Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_1__["isBmp"])(dataView) || Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_1__["isGif"])(dataView) || Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_1__["isPng"])(dataView);
  },
  options: {
    image: {
      format: 'auto',
      decode: true // if format is HTML
    }
    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
  }
};

/* harmony default export */ __webpack_exports__["default"] = (ImageLoader);


/***/ }),

/***/ "./src/image-loaders.js":
/*!******************************!*\
  !*** ./src/image-loaders.js ***!
  \******************************/
/*! exports provided: JPEGLoader, PNGLoader, GIFLoader, BMPLoader, SVGLoader, ImageLoaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JPEGLoader", function() { return JPEGLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PNGLoader", function() { return PNGLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIFLoader", function() { return GIFLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BMPLoader", function() { return BMPLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SVGLoader", function() { return SVGLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoaders", function() { return ImageLoaders; });
/* harmony import */ var _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parsers/parse-image */ "./src/lib/parsers/parse-image.js");
/* harmony import */ var _lib_parsers_parse_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-svg */ "./src/lib/parsers/parse-svg.js");
/* harmony import */ var _lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/binary-image-api/binary-image-parsers */ "./src/lib/binary-image-api/binary-image-parsers.js");
/* global __VERSION__ */ // __VERSION__ is injected by babel-plugin-version-inline




const VERSION =  true ? "2.0.0" : undefined;

const JPEGLoader = {
  id: 'jpeg',
  category: 'image',
  name: 'JPEG',
  version: VERSION,
  extensions: ['jpg', 'jpeg'],
  mimeType: 'image/jpeg',
  test: arrayBuffer => Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_2__["isJpeg"])(new DataView(arrayBuffer)),
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  // test: ,
  options: {}
};

const PNGLoader = {
  id: 'png',
  category: 'image',
  name: 'PNG',
  version: VERSION,
  extensions: ['png'],
  mimeType: 'image/png',
  test: arrayBuffer => Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_2__["isPng"])(new DataView(arrayBuffer)),
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  // test: , - Add sniffer here
  options: {}
};

const GIFLoader = {
  id: 'gif',
  category: 'image',
  name: 'GIF',
  version: VERSION,
  extensions: ['gif'],
  mimeType: 'image/gif',
  test: arrayBuffer => Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_2__["isGif"])(new DataView(arrayBuffer)),
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  options: {}
};

const BMPLoader = {
  id: 'bmp',
  category: 'image',
  name: 'BMP',
  version: VERSION,
  extensions: ['gif'],
  mimeType: 'image/gif',
  test: arrayBuffer => Object(_lib_binary_image_api_binary_image_parsers__WEBPACK_IMPORTED_MODULE_2__["isBmp"])(new DataView(arrayBuffer)),
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  options: {}
};

const SVGLoader = {
  id: 'svg',
  name: 'SVG',
  version: VERSION,
  extensions: ['svg'],
  mimeType: 'image/svg+xml',
  // test: , - Add sniffer here
  parse: _lib_parsers_parse_svg__WEBPACK_IMPORTED_MODULE_1__["default"]
};

const ImageLoaders = [
  JPEGLoader,
  PNGLoader,
  GIFLoader,
  BMPLoader,
  // WEBPLoader,
  // ICOLoader,
  SVGLoader
];


/***/ }),

/***/ "./src/image-writer.js":
/*!*****************************!*\
  !*** ./src/image-writer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encoders/encode-image */ "./src/lib/encoders/encode-image.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extensions: ['jpeg'],
  encode: _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_0__["encodeImage"],
  DEFAULT_OPTIONS: {
    type: 'png'
  }
});


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ImageLoader, ImageWriter, isImageTypeSupported, isImage, getImageType, getImageSize, getImageData, isBinaryImage, getBinaryImageMIMEType, getBinaryImageSize, loadImage, loadImageArray, loadImageCube, _JPEGLoader, _PNGLoader, _GIFLoader, _BMPLoader, _SVGLoader, _ImageLoaders, HTMLImageLoader, getSupportedImageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSupportedImageType", function() { return getSupportedImageType; });
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "./src/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "./src/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parsed-image-api/image-type */ "./src/lib/parsed-image-api/image-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return _lib_parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_2__["isImageTypeSupported"]; });

/* harmony import */ var _lib_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/parsed-image-api/parsed-image-api */ "./src/lib/parsed-image-api/parsed-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_3__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return _lib_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_3__["getImageType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_3__["getImageSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return _lib_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_3__["getImageData"]; });

/* harmony import */ var _lib_binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/binary-image-api/binary-image-api */ "./src/lib/binary-image-api/binary-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBinaryImage", function() { return _lib_binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_4__["isBinaryImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMIMEType", function() { return _lib_binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_4__["getBinaryImageMIMEType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageSize", function() { return _lib_binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_4__["getBinaryImageSize"]; });

/* harmony import */ var _lib_texture_loading_api_load_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/texture-loading-api/load-image */ "./src/lib/texture-loading-api/load-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_texture_loading_api_load_image__WEBPACK_IMPORTED_MODULE_5__["loadImage"]; });

/* harmony import */ var _lib_texture_loading_api_load_image_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/texture-loading-api/load-image-array */ "./src/lib/texture-loading-api/load-image-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return _lib_texture_loading_api_load_image_array__WEBPACK_IMPORTED_MODULE_6__["loadImageArray"]; });

/* harmony import */ var _lib_texture_loading_api_load_image_cube__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/texture-loading-api/load-image-cube */ "./src/lib/texture-loading-api/load-image-cube.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImageCube", function() { return _lib_texture_loading_api_load_image_cube__WEBPACK_IMPORTED_MODULE_7__["loadImageCube"]; });

/* harmony import */ var _image_loaders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./image-loaders */ "./src/image-loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_JPEGLoader", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["JPEGLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_PNGLoader", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["PNGLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_GIFLoader", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["GIFLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_BMPLoader", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["BMPLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_SVGLoader", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["SVGLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_ImageLoaders", function() { return _image_loaders__WEBPACK_IMPORTED_MODULE_8__["ImageLoaders"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });




// Parsed Image API



// Binary Image API


// Texture Loading API




// EXPERIMENTAL V2.0


// DEPRECATED




function getSupportedImageType(imageType) {
  return Object(_lib_parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_2__["getDefaultImageType"])(imageType);
}


/***/ }),

/***/ "./src/lib/binary-image-api/binary-image-api.js":
/*!******************************************************!*\
  !*** ./src/lib/binary-image-api/binary-image-api.js ***!
  \******************************************************/
/*! exports provided: isBinaryImage, getBinaryImageMIMEType, getBinaryImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBinaryImage", function() { return isBinaryImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMIMEType", function() { return getBinaryImageMIMEType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageSize", function() { return getBinaryImageSize; });
/* harmony import */ var _binary_image_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary-image-parsers */ "./src/lib/binary-image-api/binary-image-parsers.js");
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng

// TODO: make these functions work for Node.js buffers?
// Quarantine references to Buffer to prevent bundler from adding big polyfills
// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';
// TODO - this should be handled in @loaders.gl/polyfills



const ERR_INVALID_MIME_TYPE = `Invalid MIME type. Supported MIME types are: ${Array.from(
  _binary_image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].keys()
).join(', ')}`;

// Supported image types are PNG, JPEG, GIF and BMP.
function isBinaryImage(arrayBuffer, mimeType) {
  if (mimeType) {
    const {test} = getBinaryImageTypeHandlers(mimeType);
    const dataView = toDataView(arrayBuffer);
    return test(dataView);
  }
  // check if known type
  return Boolean(getBinaryImageMIMEType(arrayBuffer));
}

// Sniffs the contents of a file to attempt to deduce the image type
function getBinaryImageMIMEType(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Loop through each file type and see if they work.
  for (const [mimeType, {test}] of _binary_image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].entries()) {
    if (test(dataView)) {
      return mimeType;
    }
  }

  return null;
}

function getBinaryImageSize(arrayBuffer, mimeType = null) {
  mimeType = mimeType || getBinaryImageMIMEType(arrayBuffer);

  const {getSize} = getBinaryImageTypeHandlers(mimeType);

  const dataView = toDataView(arrayBuffer);
  const size = getSize(dataView);

  if (!size) {
    throw new Error(`invalid image data for type: ${mimeType}`);
  }

  return size;
}

function getBinaryImageTypeHandlers(mimeType) {
  const handlers = _binary_image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].get(mimeType);
  if (!handlers) {
    throw new Error(ERR_INVALID_MIME_TYPE);
  }
  return handlers;
}

function toDataView(data) {
  data = data.buffer || data;
  // TODO: make these functions work for Node.js buffers?
  // if (bufferToArrayBuffer) {
  //   data = bufferToArrayBuffer(data);
  // }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}


/***/ }),

/***/ "./src/lib/binary-image-api/binary-image-parsers.js":
/*!**********************************************************!*\
  !*** ./src/lib/binary-image-api/binary-image-parsers.js ***!
  \**********************************************************/
/*! exports provided: mimeTypeMap, isPng, isGif, isBmp, isJpeg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mimeTypeMap", function() { return mimeTypeMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPng", function() { return isPng; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGif", function() { return isGif; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBmp", function() { return isBmp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isJpeg", function() { return isJpeg; });
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;

const mimeTypeMap = new Map([
  ['image/png', {test: isPng, getSize: getPngSize}],
  ['image/jpeg', {test: isJpeg, getSize: getJpegSize}],
  ['image/gif', {test: isGif, getSize: getGifSize}],
  ['image/bmp', {test: isBmp, getSize: getBmpSize}]
]);

// PNG

function isPng(dataView) {
  // Check file contains the first 4 bytes of the PNG signature.
  return dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
}

function getPngSize(dataView) {
  // Extract size from a binary PNG file
  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

// GIF

function isGif(dataView) {
  // Check first 4 bytes of the GIF signature ("GIF8").
  return dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
}

// Extract size from a binary GIF file
// TODO: GIF is not this simple
function getGifSize(dataView) {
  // GIF is little endian.
  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

// BMP

// TODO: BMP is not this simple
function isBmp(dataView) {
  // Check magic number is valid (first 2 characters should be "BM").
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d;
}

function getBmpSize(dataView) {
  // BMP is little endian.
  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

// JPEG

function isJpeg(dataView) {
  // Check file contains the JPEG "start of image" (SOI) marker
  // followed by another marker.
  return (
    dataView.byteLength >= 3 &&
    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&
    dataView.getUint8(2, BIG_ENDIAN) === 0xff
  );
}

// Extract width and height from a binary JPEG file
function getJpegSize(dataView) {
  // Check file contains the JPEG "start of image" (SOI) marker.
  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  const {tableMarkers, sofMarkers} = getJpegMarkers();

  // Exclude the two byte SOI marker.
  let i = 2;
  while (i < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    // The frame that contains the width and height of the JPEG image.
    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
      };
    }

    // Miscellaneous tables/data preceding the frame header.
    if (!tableMarkers.has(marker)) {
      return null;
    }

    // Length includes size of length parameter but not the two byte header.
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  // Tables/misc header markers.
  // DQT, DHT, DAC, DRI, COM, APP_n
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  // SOF markers and DHP marker.
  // These markers are after tables/misc data.
  const sofMarkers = new Set([
    0xffc0,
    0xffc1,
    0xffc2,
    0xffc3,
    0xffc5,
    0xffc6,
    0xffc7,
    0xffc9,
    0xffca,
    0xffcb,
    0xffcd,
    0xffce,
    0xffcf,
    0xffde
  ]);

  return {tableMarkers, sofMarkers};
}


/***/ }),

/***/ "./src/lib/encoders/encode-image.js":
/*!******************************************!*\
  !*** ./src/lib/encoders/encode-image.js ***!
  \******************************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/globals */ "./src/lib/utils/globals.js");
// Image loading/saving for browser
/* global document, HTMLCanvasElement, Image */




// Returns data bytes representing a compressed image in PNG or JPG format,
// This data can be saved using file system (f) methods or
// used in a request.
// @param {Image}  image - Image or Canvas
// @param {String} opt.type='png' - png, jpg or image/png, image/jpg are valid
// @param {String} opt.dataURI= - Whether to include a data URI header

function encodeImage(image, type) {
  if (_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]._encodeImageNode) {
    return _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]._encodeImageNode(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    const canvas = image;
    return canvas.toDataURL(type);
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(image instanceof Image, 'getImageData accepts image or canvas');
  const canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);

  // Get raw image data
  const data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}


/***/ }),

/***/ "./src/lib/parsed-image-api/image-type.js":
/*!************************************************!*\
  !*** ./src/lib/parsed-image-api/image-type.js ***!
  \************************************************/
/*! exports provided: IMAGE_BITMAP_SUPPORTED, HTML_IMAGE_SUPPORTED, NODE_IMAGE_SUPPORTED, isImageTypeSupported, getDefaultImageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_BITMAP_SUPPORTED", function() { return IMAGE_BITMAP_SUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTML_IMAGE_SUPPORTED", function() { return HTML_IMAGE_SUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NODE_IMAGE_SUPPORTED", function() { return NODE_IMAGE_SUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return isImageTypeSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageType", function() { return getDefaultImageType; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "./src/lib/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* global ImageBitmap, Image */



const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const HTML_IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: "false" positives if jsdom is installed
const NODE_IMAGE_SUPPORTED = Boolean(_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode);

// Checks if a loaders.gl image type is supported
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return true;
    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;
    case 'html':
      return HTML_IMAGE_SUPPORTED;
    case 'ndarray':
      return NODE_IMAGE_SUPPORTED;
    default:
      throw new Error(`Unknown image format ${type}`);
  }
}

// Returns the best loaders.gl image type supported on current run-time environment
function getDefaultImageType() {
  if (isImageTypeSupported('ndarray')) {
    return 'ndarray';
  }
  if (isImageTypeSupported('html')) {
    return 'html';
  }
  if (isImageTypeSupported('imagebitmap')) {
    return 'imagebitmap';
  }

  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    throw new Error(`Install '@loaders.gl/polyfills' to parse images under Node.js`);
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false); // Internal error, no valid format available, should not happen
}


/***/ }),

/***/ "./src/lib/parsed-image-api/parsed-image-api.js":
/*!******************************************************!*\
  !*** ./src/lib/parsed-image-api/parsed-image-api.js ***!
  \******************************************************/
/*! exports provided: isImage, deleteImage, getImageType, getImageSize, getImageData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteImage", function() { return deleteImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return getImageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return getImageData; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* global ImageBitmap, Image */


function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}

function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;
    default:
    // Nothing to do for images and ndarrays
  }
}

function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error('Not an image');
  }
  return format;
}

function getImageSize(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
    case 'ndarray':
      return {width: image.width, height: image.height};
    case 'html':
      return {width: image.naturalWidth, height: image.naturalHeight};
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }
}

function getImageData(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
    case 'html':
      /* global document */
      const canvas = document.createElement('canvas');
      // TODO - reuse the canvas?
      const context = canvas.getContext('2d');
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      return imageData.data;
    case 'ndarray':
      return image.data;
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }
}

// PRIVATE

function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }
  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'html';
  }
  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    // Assume this is ndarray
    // TODO - this is not ndarray
    return 'ndarray';
  }
  if (Array.isArray(image)) {
    // Assume this is ndarray
    return 'ndarray';
  }
  return null;
}


/***/ }),

/***/ "./src/lib/parsers/parse-image.js":
/*!****************************************!*\
  !*** ./src/lib/parsers/parse-image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseImage; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsed-image-api/image-type */ "./src/lib/parsed-image-api/image-type.js");
/* harmony import */ var _parse_to_node_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse-to-node-image */ "./src/lib/parsers/parse-to-node-image.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-to-image */ "./src/lib/parsers/parse-to-image.js");
/* harmony import */ var _parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse-to-image-bitmap */ "./src/lib/parsers/parse-to-image-bitmap.js");
/* harmony import */ var _parse_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse-svg */ "./src/lib/parsers/parse-svg.js");








// Parse to platform defined image type (ndarray on node, ImageBitmap or HTMLImage on browser)
async function parseImage(arrayBuffer, options, context) {
  options = options || {};

  const {url} = context || {};
  if (url && /\.svg((\?|#).*)?$/.test(url)) {
    // eslint-disable-next-line
    console.warn('@loaders.gl/images: SVG parsing needs to be fixed for 2.0');
    return await Object(_parse_svg__WEBPACK_IMPORTED_MODULE_5__["default"])(arrayBuffer, options);
  }

  const format = getImageOutputFormat(options);
  switch (format) {
    case 'imagebitmap':
      return await Object(_parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__["default"])(arrayBuffer, options);
    case 'html':
      return await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_3__["default"])(arrayBuffer, options);
    case 'ndarray':
      return await Object(_parse_to_node_image__WEBPACK_IMPORTED_MODULE_2__["default"])(arrayBuffer, options);
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }
}

// The user can request a specific output format via `options.type`
// TODO - ImageBitmap vs HTMLImage depends on worker threads...
function getImageOutputFormat(options = {}) {
  const imageOptions = options.image || {};
  const type = imageOptions.type || 'auto';

  switch (type) {
    case 'imagebitmap':
    case 'html':
    case 'ndarray':
      // Check that it is actually supported
      if (!Object(_parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_1__["isImageTypeSupported"])(type)) {
        throw new Error(`Requested image type ${type} not available in current environment`);
      }
      return type;

    case 'auto':
      return Object(_parsed_image_api_image_type__WEBPACK_IMPORTED_MODULE_1__["getDefaultImageType"])();

    default:
      // Note: isImageTypeSupported throws on unknown type
      throw new Error(`Unknown image format ${type}`);
  }
}


/***/ }),

/***/ "./src/lib/parsers/parse-svg.js":
/*!**************************************!*\
  !*** ./src/lib/parsers/parse-svg.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseSVG; });
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-to-image */ "./src/lib/parsers/parse-to-image.js");
/* global TextDecoder, btoa */ // encodeURLComponent,


async function parseSVG(arrayBuffer, options) {
  // Prepare a properly tagged data URL, and load using normal mechanism
  const textDecoder = new TextDecoder();
  const xmlText = textDecoder.decode(arrayBuffer);
  // TODO Escape in browser to support e.g. Chinese characters
  // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {
  //   xmlText = unescape(encodeURLComponent(xmlText));
  // }
  // base64 encoding is safer. utf-8 fails in some browsers
  const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
  return await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_0__["loadToImage"])(src, options);
}


/***/ }),

/***/ "./src/lib/parsers/parse-to-image-bitmap.js":
/*!**************************************************!*\
  !*** ./src/lib/parsers/parse-to-image-bitmap.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImageBitmap; });
/* global Blob, createImageBitmap */

// Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data
// Supported on worker threads, not supported on Edge, IE11 and Safari
// https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility

function parseToImageBitmap(arrayBuffer, options) {
  // NOTE: In some cases unnecessary conversion to blob (response, blob, file input)
  const blob = new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed...
  const imagebitmapOptions = options && options.imagebitmap;
  return imagebitmapOptions ? createImageBitmap(blob) : createImageBitmap(blob, imagebitmapOptions);
}


/***/ }),

/***/ "./src/lib/parsers/parse-to-image.js":
/*!*******************************************!*\
  !*** ./src/lib/parsers/parse-to-image.js ***!
  \*******************************************/
/*! exports provided: default, loadToImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToImage", function() { return loadToImage; });
/* global self, Image, Blob */

// Parses html image from array buffer
async function parseToImage(arrayBuffer, options) {
  // Note: image parsing requires conversion to Blob (for createObjectURL).
  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...
  // But presumably not worth adding 'blob' flag to loader objects?

  // TODO - how to determine mime type? Param? Sniff here?
  const mimeType = 'image/jpeg';
  const blob = new Blob([arrayBuffer], {type: mimeType});
  const URL = self.URL || self.webkitURL;
  const objectUrl = URL.createObjectURL(blob);
  try {
    return await loadToImage(objectUrl, options);
  } finally {
    URL.revokeObjectURL(objectUrl);
  }
}

async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;

  // The `image.onload()` callback does not guarantee that the image has been decoded
  // so a main thread "freeze" can be incurred when using the image for the first time.
  // `Image.decode()` returns a promise that completes when image is decoded.

  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode
  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`
  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }

  // Create a promise that tracks onload/onerror callbacks
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ "./src/lib/parsers/parse-to-node-image.js":
/*!************************************************!*\
  !*** ./src/lib/parsers/parse-to-node-image.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToNodeImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "./src/lib/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binary-image-api/binary-image-api */ "./src/lib/binary-image-api/binary-image-api.js");




// Use polyfills if installed to p[arsed image using get-pixels
function parseToNodeImage(arrayBuffer, options) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode); // '@loaders.gl/polyfills not installed'
  const mimeType = Object(_binary_image_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMIMEType"])(arrayBuffer);
  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode(arrayBuffer, mimeType, options);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/async-deep-map.js":
/*!*******************************************************!*\
  !*** ./src/lib/texture-loading-api/async-deep-map.js ***!
  \*******************************************************/
/*! exports provided: asyncDeepMap, mapSubtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asyncDeepMap", function() { return asyncDeepMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapSubtree", function() { return mapSubtree; });
/*
Asynchronously maps a deep structure of values (e.g. objects and arrays of urls).

E.g. a mipmapped cubemap
{
  [CUBE_FACE_FRONT]: [
    "image-front-0.jpg",
    "image-front-1.jpg",
    "image-front-2.jpg",
  ],
  [CUBE_MAP_BACK]: [
    ...
  ]
}
*/

const isObject = value => value && typeof value === 'object';

// Loads a deep structure of urls (objects and arrays of urls)
// Returns an object with six key-value pairs containing the images (or image mip arrays)
// for each cube face
async function asyncDeepMap(tree, func, options = {}) {
  return await mapSubtree(tree, func, options);
}

async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }

  if (isObject(object)) {
    return await mapObject(object, func, options);
  }

  // TODO - ignore non-urls, non-arraybuffers?
  const url = object;
  return await func(url, options);
}

// HELPERS

async function mapObject(object, func, options) {
  const promises = [];
  const values = {};

  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }

  await Promise.all(promises);

  return values;
}

async function mapArray(urlArray, func, options = {}) {
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/deep-load.js":
/*!**************************************************!*\
  !*** ./src/lib/texture-loading-api/deep-load.js ***!
  \**************************************************/
/*! exports provided: deepLoad, shallowLoad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepLoad", function() { return deepLoad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowLoad", function() { return shallowLoad; });
/* harmony import */ var _async_deep_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async-deep-map */ "./src/lib/texture-loading-api/async-deep-map.js");
/* global fetch */


async function deepLoad(urlTree, load, options) {
  return await Object(_async_deep_map__WEBPACK_IMPORTED_MODULE_0__["asyncDeepMap"])(urlTree, url => shallowLoad(url, load, options));
}

async function shallowLoad(url, load, options) {
  // console.error('loading', url);
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/generate-url.js":
/*!*****************************************************!*\
  !*** ./src/lib/texture-loading-api/generate-url.js ***!
  \*****************************************************/
/*! exports provided: generateUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUrl", function() { return generateUrl; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");



// Generate a url by calling getUrl with mix of options, applying options.baseUrl
function generateUrl(getUrl, options, urlOptions) {
  // Get url
  let url = getUrl;
  if (typeof getUrl === 'function') {
    url = getUrl({...options, ...urlOptions});
  }
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof url === 'string');

  // Apply options.baseUrl
  const {baseUrl} = options;
  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
  }

  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["resolvePath"])(url);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/load-image-array.js":
/*!*********************************************************!*\
  !*** ./src/lib/texture-loading-api/load-image-array.js ***!
  \*********************************************************/
/*! exports provided: loadImageArray, getImageArrayUrls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return loadImageArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageArrayUrls", function() { return getImageArrayUrls; });
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/parse-image */ "./src/lib/parsers/parse-image.js");
/* harmony import */ var _load_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load-image */ "./src/lib/texture-loading-api/load-image.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deep-load */ "./src/lib/texture-loading-api/deep-load.js");




async function loadImageArray(count, getUrl, options = {}) {
  const imageUrls = await getImageArrayUrls(count, getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_2__["deepLoad"])(imageUrls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"], options);
}

async function getImageArrayUrls(count, getUrl, options = {}) {
  const promises = [];
  for (let index = 0; index < count; index++) {
    const promise = Object(_load_image__WEBPACK_IMPORTED_MODULE_1__["getImageUrls"])(getUrl, options, {index});
    promises.push(promise);
  }
  return await Promise.all(promises);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/load-image-cube.js":
/*!********************************************************!*\
  !*** ./src/lib/texture-loading-api/load-image-cube.js ***!
  \********************************************************/
/*! exports provided: getImageCubeUrls, loadImageCube */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageCubeUrls", function() { return getImageCubeUrls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImageCube", function() { return loadImageCube; });
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/parse-image */ "./src/lib/parsers/parse-image.js");
/* harmony import */ var _load_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load-image */ "./src/lib/texture-loading-api/load-image.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deep-load */ "./src/lib/texture-loading-api/deep-load.js");




// Returned map will be have keys corresponding to GL cubemap constants
const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;

const CUBE_FACES = [
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}
];

// Returns an object with six key-value pairs containing the urls (or url mip arrays)
// for each cube face
async function getImageCubeUrls(getUrl, options) {
  // Calculate URLs
  const urls = {};
  const promises = [];

  let index = 0;
  for (const face in CUBE_FACES) {
    const faceValues = CUBE_FACES[index];
    const promise = Object(_load_image__WEBPACK_IMPORTED_MODULE_1__["getImageUrls"])(getUrl, options, {...faceValues, index: index++}).then(url => {
      urls[face] = url;
    });
    promises.push(promise);
  }

  await Promise.all(promises);

  return urls;
}

// Returns an object with six key-value pairs containing the images (or image mip arrays)
// for each cube face
async function loadImageCube(getUrl, options = {}) {
  const urls = await getImageCubeUrls(getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_2__["deepLoad"])(urls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"], options);
}


/***/ }),

/***/ "./src/lib/texture-loading-api/load-image.js":
/*!***************************************************!*\
  !*** ./src/lib/texture-loading-api/load-image.js ***!
  \***************************************************/
/*! exports provided: loadImage, getImageUrls, getMipLevels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageUrls", function() { return getImageUrls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMipLevels", function() { return getMipLevels; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/parse-image */ "./src/lib/parsers/parse-image.js");
/* harmony import */ var _parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsed-image-api/parsed-image-api */ "./src/lib/parsed-image-api/parsed-image-api.js");
/* harmony import */ var _generate_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generate-url */ "./src/lib/texture-loading-api/generate-url.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deep-load */ "./src/lib/texture-loading-api/deep-load.js");






async function loadImage(getUrl, options = {}) {
  const imageUrls = await getImageUrls(getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["deepLoad"])(imageUrls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);
}

async function getImageUrls(getUrl, options, urlOptions = {}) {
  const mipLevels = (options && options.image && options.image.mipLevels) || 0;
  return mipLevels !== 0
    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)
    : Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, urlOptions);
}

async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];

  // If no mip levels supplied, we need to load the level 0 image and calculate based on size
  if (mipLevels === 'auto') {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, {...urlOptions, lod: 0});
    const image = await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["shallowLoad"])(url, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);

    const {width, height} = Object(_parsed_image_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__["getImageSize"])(image);
    mipLevels = getMipLevels({width, height});

    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?
    urls.push(url);
  }

  // We now know how many mipLevels we need, remaining image urls can now be constructed
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(mipLevels > 0);

  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, {...urlOptions, lod: mipLevel});
    urls.push(url);
  }

  return urls;
}

// Calculates number of mipmaps based on texture size (log2)
function getMipLevels({width, height}) {
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}


/***/ }),

/***/ "./src/lib/utils/assert.js":
/*!*********************************!*\
  !*** ./src/lib/utils/assert.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}


/***/ }),

/***/ "./src/lib/utils/globals.js":
/*!**********************************!*\
  !*** ./src/lib/utils/globals.js ***!
  \**********************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, window, global, document, self, importScripts */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const isWorker = typeof importScripts === 'function';

// Extract node major version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ 0:
/*!**************************************!*\
  !*** ./require-utils.node (ignored) ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});