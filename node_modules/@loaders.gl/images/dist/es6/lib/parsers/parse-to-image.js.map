{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.js"],"names":["parseToImage","arrayBuffer","options","mimeType","blob","Blob","type","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","url","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"mappings":"AAGA,eAAe,eAAeA,YAAf,CAA4BC,WAA5B,EAAyCC,OAAzC,EAAkD;AAM/D,QAAMC,QAAQ,GAAG,YAAjB;AACA,QAAMC,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACJ,WAAD,CAAT,EAAwB;AAACK,IAAAA,IAAI,EAAEH;AAAP,GAAxB,CAAb;AACA,QAAMI,GAAG,GAAGC,IAAI,CAACD,GAAL,IAAYC,IAAI,CAACC,SAA7B;AACA,QAAMC,SAAS,GAAGH,GAAG,CAACI,eAAJ,CAAoBP,IAApB,CAAlB;;AACA,MAAI;AACF,WAAO,MAAMQ,WAAW,CAACF,SAAD,EAAYR,OAAZ,CAAxB;AACD,GAFD,SAEU;AACRK,IAAAA,GAAG,CAACM,eAAJ,CAAoBH,SAApB;AACD;AACF;AAED,OAAO,eAAeE,WAAf,CAA2BE,GAA3B,EAAgCZ,OAAhC,EAAyC;AAC9C,QAAMa,KAAK,GAAG,IAAIC,KAAJ,EAAd;AACAD,EAAAA,KAAK,CAACE,GAAN,GAAYH,GAAZ;;AASA,MAAIZ,OAAO,CAACa,KAAR,IAAiBb,OAAO,CAACa,KAAR,CAAcG,MAA/B,IAAyCH,KAAK,CAACG,MAAnD,EAA2D;AACzD,UAAMH,KAAK,CAACG,MAAN,EAAN;AACA,WAAOH,KAAP;AACD;;AAGD,SAAO,MAAM,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC5C,QAAI;AACFN,MAAAA,KAAK,CAACO,MAAN,GAAe,MAAMF,OAAO,CAACL,KAAD,CAA5B;;AACAA,MAAAA,KAAK,CAACQ,OAAN,GAAgBC,GAAG,IAAIH,MAAM,CAAC,IAAII,KAAJ,gCAAkCX,GAAlC,eAA0CU,GAA1C,EAAD,CAA7B;AACD,KAHD,CAGE,OAAOE,KAAP,EAAc;AACdL,MAAAA,MAAM,CAACK,KAAD,CAAN;AACD;AACF,GAPY,CAAb;AAQD","sourcesContent":["/* global self, Image, Blob */\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  // TODO - how to determine mime type? Param? Sniff here?\n  const mimeType = 'image/jpeg';\n  const blob = new Blob([arrayBuffer], {type: mimeType});\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = URL.createObjectURL(blob);\n  try {\n    return await loadToImage(objectUrl, options);\n  } finally {\n    URL.revokeObjectURL(objectUrl);\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"file":"parse-to-image.js"}