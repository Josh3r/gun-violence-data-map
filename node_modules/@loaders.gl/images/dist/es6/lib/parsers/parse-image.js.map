{"version":3,"sources":["../../../../src/lib/parsers/parse-image.js"],"names":["assert","isImageTypeSupported","getDefaultImageType","parseToNodeImage","parseToImage","parseToImageBitmap","parseSVG","parseImage","arrayBuffer","options","context","url","test","console","warn","format","getImageOutputFormat","imageOptions","image","type","Error"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,iBAAnB;AACA,SAAQC,oBAAR,EAA8BC,mBAA9B,QAAwD,gCAAxD;AAEA,OAAOC,gBAAP,MAA6B,uBAA7B;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,OAAOC,kBAAP,MAA+B,yBAA/B;AACA,OAAOC,QAAP,MAAqB,aAArB;AAGA,eAAe,eAAeC,UAAf,CAA0BC,WAA1B,EAAuCC,OAAvC,EAAgDC,OAAhD,EAAyD;AACtED,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAM;AAACE,IAAAA;AAAD,MAAQD,OAAO,IAAI,EAAzB;;AACA,MAAIC,GAAG,IAAI,oBAAoBC,IAApB,CAAyBD,GAAzB,CAAX,EAA0C;AAExCE,IAAAA,OAAO,CAACC,IAAR,CAAa,2DAAb;AACA,WAAO,MAAMR,QAAQ,CAACE,WAAD,EAAcC,OAAd,CAArB;AACD;;AAED,QAAMM,MAAM,GAAGC,oBAAoB,CAACP,OAAD,CAAnC;;AACA,UAAQM,MAAR;AACE,SAAK,aAAL;AACE,aAAO,MAAMV,kBAAkB,CAACG,WAAD,EAAcC,OAAd,CAA/B;;AACF,SAAK,MAAL;AACE,aAAO,MAAML,YAAY,CAACI,WAAD,EAAcC,OAAd,CAAzB;;AACF,SAAK,SAAL;AACE,aAAO,MAAMN,gBAAgB,CAACK,WAAD,EAAcC,OAAd,CAA7B;;AACF;AACE,aAAOT,MAAM,CAAC,KAAD,CAAb;AARJ;AAUD;;AAID,SAASgB,oBAAT,CAA8BP,OAAO,GAAG,EAAxC,EAA4C;AAC1C,QAAMQ,YAAY,GAAGR,OAAO,CAACS,KAAR,IAAiB,EAAtC;AACA,QAAMC,IAAI,GAAGF,YAAY,CAACE,IAAb,IAAqB,MAAlC;;AAEA,UAAQA,IAAR;AACE,SAAK,aAAL;AACA,SAAK,MAAL;AACA,SAAK,SAAL;AAEE,UAAI,CAAClB,oBAAoB,CAACkB,IAAD,CAAzB,EAAiC;AAC/B,cAAM,IAAIC,KAAJ,gCAAkCD,IAAlC,2CAAN;AACD;;AACD,aAAOA,IAAP;;AAEF,SAAK,MAAL;AACE,aAAOjB,mBAAmB,EAA1B;;AAEF;AAEE,YAAM,IAAIkB,KAAJ,gCAAkCD,IAAlC,EAAN;AAfJ;AAiBD","sourcesContent":["import assert from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../parsed-image-api/image-type';\n\nimport parseToNodeImage from './parse-to-node-image';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseSVG from './parse-svg';\n\n// Parse to platform defined image type (ndarray on node, ImageBitmap or HTMLImage on browser)\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n\n  const {url} = context || {};\n  if (url && /\\.svg((\\?|#).*)?$/.test(url)) {\n    // eslint-disable-next-line\n    console.warn('@loaders.gl/images: SVG parsing needs to be fixed for 2.0');\n    return await parseSVG(arrayBuffer, options);\n  }\n\n  const format = getImageOutputFormat(options);\n  switch (format) {\n    case 'imagebitmap':\n      return await parseToImageBitmap(arrayBuffer, options);\n    case 'html':\n      return await parseToImage(arrayBuffer, options);\n    case 'ndarray':\n      return await parseToNodeImage(arrayBuffer, options);\n    default:\n      return assert(false);\n  }\n}\n\n// The user can request a specific output format via `options.type`\n// TODO - ImageBitmap vs HTMLImage depends on worker threads...\nfunction getImageOutputFormat(options = {}) {\n  const imageOptions = options.image || {};\n  const type = imageOptions.type || 'auto';\n\n  switch (type) {\n    case 'imagebitmap':\n    case 'html':\n    case 'ndarray':\n      // Check that it is actually supported\n      if (!isImageTypeSupported(type)) {\n        throw new Error(`Requested image type ${type} not available in current environment`);\n      }\n      return type;\n\n    case 'auto':\n      return getDefaultImageType();\n\n    default:\n      // Note: isImageTypeSupported throws on unknown type\n      throw new Error(`Unknown image format ${type}`);\n  }\n}\n"],"file":"parse-image.js"}