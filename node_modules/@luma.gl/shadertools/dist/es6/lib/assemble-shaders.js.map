{"version":3,"sources":["../../../src/lib/assemble-shaders.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","resolveModules","getPlatformShaderDefines","getVersionDefines","injectShader","DECLARATION_INJECT_MARKER","assert","INJECT_SHADER_DECLARATIONS","SHADER_TYPE","FRAGMENT_SHADER_PROLOGUE","assembleShaders","gl","opts","vs","fs","modules","assembleShader","Object","assign","source","type","getUniforms","assembleGetUniforms","id","defines","hookFunctions","inject","prologue","log","isVertex","sourceLines","split","glslVersion","versionLine","coreSource","indexOf","slice","join","allDefines","forEach","module","getDefines","assembledSource","getShaderName","getShaderType","getApplicationDefines","normalizeHookFunctions","hookInjections","mainInjections","key","injection","order","match","checkDeprecations","moduleSource","getModuleSource","injections","push","getHookFunctions","uniforms","moduleUniforms","toUpperCase","injectShaderName","count","sourceText","define","value","Number","isFinite","result","hookName","hookFunction","signature","header","sort","a","b","footer","hook","trim","stage","name","replace"],"mappings":"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","sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {id, source, type, modules, defines = {}, hookFunctions = [], inject = {}, prologue = true, log}\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  hookFunctions = normalizeHookFunctions(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[type];\n    for (const key in injections) {\n      if (key.match(/^(v|f)s:#/)) {\n        mainInjections[key] = mainInjections[key] || [];\n        mainInjections[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach(hook => {\n    let opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n"],"file":"assemble-shaders.js"}